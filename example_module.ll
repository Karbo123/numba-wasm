; ModuleID = 'function_library'
source_filename = "<string>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@global_counter = global i32 0
@_ZN08NumbaEnv14example_module7example6squareB2v1B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEd = common global i8* null
@_ZN08NumbaEnv5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v2B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi = common global i8* null
@.const.picklebuf.140041119024640 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([186 x i8], [186 x i8]* @.const.pickledata.140041119024640, i32 0, i32 0), i32 186, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.140041119024640.sha1, i32 0, i32 0) }
@.const.picklebuf.140041119524608 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.const.pickledata.140041119524608, i32 0, i32 0), i32 69, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.140041119524608.sha1, i32 0, i32 0) }
@.const.pickledata.140041119524608 = internal constant [69 x i8] c"\80\04\95:\00\00\00\00\00\00\00\8C\08builtins\94\8C\11ZeroDivisionError\94\93\94\8C\10division by zero\94\85\94N\87\94."
@.const.pickledata.140041119524608.sha1 = internal constant [20 x i8] c"\B2\80\08\A0\F8\8B\AD_\F0\F0$>\84\DA\B9\0C\AB\19\B3f"
@.const.pickledata.140041119024640 = internal constant [186 x i8] c"\80\04\95\AF\00\00\00\00\00\00\00\8C\08builtins\94\8C\0DOverflowError\94\93\94)\8C\09int_power\94\8C{/home/runner/.cache/pypoetry/virtualenvs/example-module-IBmFCHpo-py3.9/lib/python3.9/site-packages/numba/cpython/numbers.py\94K\DE\87\94\87\94."
@.const.pickledata.140041119024640.sha1 = internal constant [20 x i8] c"-\08\0E\1C&\BB\EB\140QO\C3\AD\F1\D2\C4\FBT\C9X"
@_ZN08NumbaEnv14example_module7example18new_array_functionB2v3B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj11ol_np_zeros12_3clocals_3e4implB2v4B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29 = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj11ol_np_empty12_3clocals_3e4implB2v5B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29 = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj18ol_array_zero_fill12_3clocals_3e4implB2v8B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE = common global i8* null
@.const.picklebuf.140041118885248 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.const.pickledata.140041118885248, i32 0, i32 0), i32 81, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.140041118885248.sha1, i32 0, i32 0) }
@.const.picklebuf.140041119024896 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([77 x i8], [77 x i8]* @.const.pickledata.140041119024896, i32 0, i32 0), i32 77, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.140041119024896.sha1, i32 0, i32 0) }
@.const.picklebuf.140041119522880 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([137 x i8], [137 x i8]* @.const.pickledata.140041119522880, i32 0, i32 0), i32 137, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.140041119522880.sha1, i32 0, i32 0) }
@.const.picklebuf.140041117992832 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([86 x i8], [86 x i8]* @.const.pickledata.140041117992832, i32 0, i32 0), i32 86, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.140041117992832.sha1, i32 0, i32 0) }
@.const.pickledata.140041117992832 = internal constant [86 x i8] c"\80\04\95K\00\00\00\00\00\00\00\8C\08builtins\94\8C\0BMemoryError\94\93\94\8C'Allocation failed (probably too large).\94\85\94N\87\94."
@.const.pickledata.140041117992832.sha1 = internal constant [20 x i8] c"\BA(\9D\81\F0\\p \F3G|\15sH\04\DFe\AB\E2\09"
@.const.pickledata.140041119522880 = internal constant [137 x i8] c"\80\04\95~\00\00\00\00\00\00\00\8C\08builtins\94\8C\0AValueError\94\93\94\8C[array is too big; `arr.size * arr.dtype.itemsize` is larger than the maximum possible size.\94\85\94N\87\94."
@.const.pickledata.140041119522880.sha1 = internal constant [20 x i8] c"X\E1N\CC\B5\07\B1\E0 i\81t\02#\E6\85\CB\8C<W"
@.const.pickledata.140041119024896 = internal constant [77 x i8] c"\80\04\95B\00\00\00\00\00\00\00\8C\08builtins\94\8C\0AValueError\94\93\94\8C\1Fnegative dimensions not allowed\94\85\94N\87\94."
@.const.pickledata.140041119024896.sha1 = internal constant [20 x i8] c"3\1B\85c\BD\B9\DA\C8\1B8B\22s\05,Ho\C1pk"
@.const.pickledata.140041118885248 = internal constant [81 x i8] c"\80\04\95F\00\00\00\00\00\00\00\8C\08builtins\94\8C\0AValueError\94\93\94\8C#Cannot safely convert value to intp\94\85\94N\87\94."
@.const.pickledata.140041118885248.sha1 = internal constant [20 x i8] c"M\D0\A5\17S\C7\DCs\85\B2u\D9R\BDR\D8\A29\C2\FF"
@_ZN08NumbaEnv14example_module7example21modify_array_functionB2v9B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE = common global i8* null
@_ZN08NumbaEnv14example_module7example30modify_array_in_place_functionB3v10B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE = common global i8* null
@_ZN08NumbaEnv14example_module7example29new_and_modify_array_functionB3v11B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE = common global i8* null
@numba.dynamic.globals.7f5ddd208720 = linkonce global i8* inttoptr (i32 -585070816 to i8*)
@numba.dynamic.globals.7f5ddd08f0e0 = linkonce global i8* inttoptr (i32 -586616608 to i8*)
@_ZN08NumbaEnv14example_module7example34specially_named_new_array_functionB3v12B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE = common global i8* null
@_ZN08NumbaEnv14example_module7example33increment_global_counter_functionB3v13B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE = common global i8* null
@_ZN08NumbaEnv14example_module7example18get_global_counterB3v14B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE = common global i8* null
@_ZN08NumbaEnv14example_module7example8sum_to_xB3v15B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEj = common global i8* null

define i32 @_ZN14example_module7example6squareB2v1B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEd(double* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, double %arg.input_value) {
entry:
  %.5 = alloca double, align 8
  store double 0.000000e+00, double* %.5, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %try_state = alloca i32, align 4
  store i32 0, i32* %try_state, align 4
  store double 0.000000e+00, double* %.5, align 8
  %.9 = call i32 @_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v2B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi(double* %.5, { i8*, i32, i8* }** %excinfo.1, double %arg.input_value, i32 2)
  %.10 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.11 = icmp eq i32 %.9, 0
  %.12 = icmp eq i32 %.9, -2
  %.15 = or i1 %.11, %.12
  %.16 = xor i1 %.15, true
  %.17 = icmp sge i32 %.9, 1
  %.18 = select i1 %.17, { i8*, i32, i8* }* %.10, { i8*, i32, i8* }* undef
  %.19 = load double, double* %.5, align 8
  br i1 %.16, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store i32 0, i32* %try_state, align 4
  %.23 = load i32, i32* %try_state, align 4
  %.24 = icmp ugt i32 %.23, 0
  %.25 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.18, { i8*, i32, i8* }** %excinfo, align 8
  %.27 = xor i1 %.24, true
  br i1 %.27, label %B0.if.if, label %B0.endif

B0.endif:                                         ; preds = %B0.if, %entry
  store double %.19, double* %retptr, align 8
  ret i32 0

B0.if.if:                                         ; preds = %B0.if
  ret i32 %.9, !ret_is_raise !1
}

define linkonce_odr i32 @_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v2B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi(double* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, double %arg.a, i32 %arg.b) {
entry:
  %b = alloca i32, align 4
  store i32 0, i32* %b, align 4
  %r = alloca double, align 8
  store double 0.000000e+00, double* %r, align 8
  %a.1 = alloca double, align 8
  store double 0.000000e+00, double* %a.1, align 8
  %invert = alloca i1, align 1
  store i1 false, i1* %invert, align 1
  %exp = alloca i64, align 8
  store i64 0, i64* %exp, align 8
  %try_state = alloca i32, align 4
  store i32 0, i32* %try_state, align 4
  %invert.2 = alloca i1, align 1
  store i1 false, i1* %invert.2, align 1
  %exp.3 = alloca i64, align 8
  store i64 0, i64* %exp.3, align 8
  %r.2 = alloca double, align 8
  store double 0.000000e+00, double* %r.2, align 8
  %a.1.2 = alloca double, align 8
  store double 0.000000e+00, double* %a.1.2, align 8
  %exp.4 = alloca i64, align 8
  store i64 0, i64* %exp.4, align 8
  %r.3 = alloca double, align 8
  store double 0.000000e+00, double* %r.3, align 8
  store i32 %arg.b, i32* %b, align 4
  %.8 = sitofp i32 1 to double
  %.10 = load double, double* %r, align 8
  store double %.8, double* %r, align 8
  %.13 = load double, double* %a.1, align 8
  store double %arg.a, double* %a.1, align 8
  %.15 = load i32, i32* %b, align 4
  %.16 = icmp slt i32 %.15, 0
  br i1 %.16, label %B26, label %B98

B26:                                              ; preds = %entry
  %.19 = load i1, i1* %invert, align 1
  store i1 true, i1* %invert, align 1
  %.21 = load i32, i32* %b, align 4
  %.22 = sub i32 0, %.21
  %.23 = sext i32 %.22 to i64
  %.25 = load i64, i64* %exp, align 8
  store i64 %.23, i64* %exp, align 8
  %.27 = load i64, i64* %exp, align 8
  %.28 = sext i32 0 to i64
  %.29 = icmp slt i64 %.27, %.28
  br i1 %.29, label %B44, label %B48

B44:                                              ; preds = %B26
  %.31 = load double, double* %r, align 8
  store double 0.000000e+00, double* %r, align 8
  %.33 = load i1, i1* %invert, align 1
  store i1 false, i1* %invert, align 1
  %.35 = load i64, i64* %exp, align 8
  store i64 0, i64* %exp, align 8
  %.37 = load i32, i32* %b, align 4
  store i32 0, i32* %b, align 4
  %.39 = load double, double* %a.1, align 8
  store double 0.000000e+00, double* %a.1, align 8
  store { i8*, i32, i8* }* @.const.picklebuf.140041119024640, { i8*, i32, i8* }** %excinfo, align 8
  store i32 0, i32* %try_state, align 4
  %.44 = load i32, i32* %try_state, align 4
  %.46 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 1, !ret_is_raise !1

B48:                                              ; preds = %B26
  %.48 = load i1, i1* %invert, align 1
  %.50 = load i1, i1* %invert.2, align 1
  store i1 true, i1* %invert.2, align 1
  %.52 = load i1, i1* %invert, align 1
  store i1 false, i1* %invert, align 1
  %.54 = load i64, i64* %exp, align 8
  %.56 = load i64, i64* %exp.3, align 8
  store i64 %.54, i64* %exp.3, align 8
  %.58 = load i64, i64* %exp, align 8
  store i64 0, i64* %exp, align 8
  br label %B106

B98:                                              ; preds = %entry
  %.61 = load i1, i1* %invert.2, align 1
  store i1 false, i1* %invert.2, align 1
  %.63 = load i32, i32* %b, align 4
  %.64 = sext i32 %.63 to i64
  %.65 = load i64, i64* %exp.3, align 8
  store i64 %.64, i64* %exp.3, align 8
  br label %B106

B106:                                             ; preds = %B98, %B48
  %.68 = load double, double* %r, align 8
  %.70 = load double, double* %r.2, align 8
  store double %.68, double* %r.2, align 8
  %.72 = load double, double* %r, align 8
  store double 0.000000e+00, double* %r, align 8
  %.74 = load double, double* %a.1, align 8
  %.76 = load double, double* %a.1.2, align 8
  store double %.74, double* %a.1.2, align 8
  %.78 = load i64, i64* %exp.3, align 8
  %.80 = load i64, i64* %exp.4, align 8
  store i64 %.78, i64* %exp.4, align 8
  %.82 = load i64, i64* %exp.3, align 8
  %.83 = sext i32 65536 to i64
  %.84 = icmp sgt i64 %.82, %.83
  %.85 = load i64, i64* %exp.3, align 8
  store i64 0, i64* %exp.3, align 8
  br i1 %.84, label %B114, label %B130.preheader

B130.preheader:                                   ; preds = %B106
  %.1061 = load i32, i32* %b, align 4
  store i32 0, i32* %b, align 4
  %.1082 = load double, double* %a.1, align 8
  store double 0.000000e+00, double* %a.1, align 8
  %.1103 = load i64, i64* %exp.4, align 8
  %.111 = sext i32 0 to i64
  %.1124 = icmp ne i64 %.1103, %.111
  br i1 %.1124, label %B138.lr.ph, label %B172

B138.lr.ph:                                       ; preds = %B130.preheader
  %r.2.promoted = load double, double* %r.2, align 8
  %exp.4.promoted = load i64, i64* %exp.4, align 8
  %a.1.2.promoted = load double, double* %a.1.2, align 8
  br label %B138

B114:                                             ; preds = %B106
  %.88 = load double, double* %r.2, align 8
  store double 0.000000e+00, double* %r.2, align 8
  %.90 = load i1, i1* %invert.2, align 1
  store i1 false, i1* %invert.2, align 1
  %.92 = load i64, i64* %exp.4, align 8
  store i64 0, i64* %exp.4, align 8
  %.94 = load double, double* %a.1.2, align 8
  store double 0.000000e+00, double* %a.1.2, align 8
  %.96 = load i32, i32* %b, align 4
  %.97 = sitofp i32 %.96 to double
  %.98 = load i32, i32* %b, align 4
  store i32 0, i32* %b, align 4
  %.100 = load double, double* %a.1, align 8
  %.101 = call double @llvm.pow.f64(double %.100, double %.97)
  %.102 = load double, double* %a.1, align 8
  store double 0.000000e+00, double* %a.1, align 8
  store double %.101, double* %retptr, align 8
  ret i32 0

B138:                                             ; preds = %B138, %B138.lr.ph
  %.1437 = phi double [ %a.1.2.promoted, %B138.lr.ph ], [ %.143, %B138 ]
  %.1386 = phi i64 [ %exp.4.promoted, %B138.lr.ph ], [ %.138, %B138 ]
  %.1315 = phi double [ %r.2.promoted, %B138.lr.ph ], [ %spec.select, %B138 ]
  %.120 = and i64 %.1386, 1
  %.121 = icmp ne i64 %.120, 0
  %.125 = fmul double %.1315, %.1437
  %spec.select = select i1 %.121, double %.125, double %.1315
  %.138 = ashr i64 %.1386, 1
  %.143 = fmul double %.1437, %.1437
  %.112 = icmp ne i64 %.138, %.111
  br i1 %.112, label %B138, label %B130.B172_crit_edge

B130.B172_crit_edge:                              ; preds = %B138
  store double %spec.select, double* %r.2, align 8
  store double 0.000000e+00, double* %r.3, align 8
  store i64 %.138, i64* %exp.4, align 8
  store double %.143, double* %a.1.2, align 8
  store i32 0, i32* %b, align 4
  store double 0.000000e+00, double* %a.1, align 8
  br label %B172

B172:                                             ; preds = %B130.B172_crit_edge, %B130.preheader
  %.147 = load i64, i64* %exp.4, align 8
  store i64 0, i64* %exp.4, align 8
  %.149 = load double, double* %a.1.2, align 8
  store double 0.000000e+00, double* %a.1.2, align 8
  %.151 = load i1, i1* %invert.2, align 1
  %.152 = load i1, i1* %invert.2, align 1
  store i1 false, i1* %invert.2, align 1
  %.155 = load double, double* %r.2, align 8
  br i1 %.151, label %B176, label %B184

B176:                                             ; preds = %B172
  %.156 = fcmp oeq double %.155, 0.000000e+00
  br i1 %.156, label %B176.if, label %B176.endif, !prof !0

B184:                                             ; preds = %B172
  %.169 = load double, double* %r.2, align 8
  store double 0.000000e+00, double* %r.2, align 8
  store double %.155, double* %retptr, align 8
  ret i32 0

B176.if:                                          ; preds = %B176
  store { i8*, i32, i8* }* @.const.picklebuf.140041119524608, { i8*, i32, i8* }** %excinfo, align 8
  %.159 = load i32, i32* %try_state, align 4
  %.161 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 1, !ret_is_raise !1

B176.endif:                                       ; preds = %B176
  %.163 = fdiv double 1.000000e+00, %.155
  %.164 = load double, double* %r.2, align 8
  store double 0.000000e+00, double* %r.2, align 8
  store double %.163, double* %retptr, align 8
  ret i32 0
}

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double, double) #0

define double @example_module.example.square(double %.1) {
entry:
  %.3 = alloca double, align 8
  store double 0.000000e+00, double* %.3, align 8
  store double 0.000000e+00, double* %.3, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.7 = call i32 @_ZN14example_module7example6squareB2v1B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEd(double* %.3, { i8*, i32, i8* }** %excinfo, double %.1) #1
  %.8 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.9 = icmp eq i32 %.7, 0
  %.10 = icmp eq i32 %.7, -2
  %.13 = or i1 %.9, %.10
  %.14 = xor i1 %.13, true
  %.15 = icmp sge i32 %.7, 1
  %.16 = select i1 %.15, { i8*, i32, i8* }* %.8, { i8*, i32, i8* }* undef
  %.17 = load double, double* %.3, align 8
  ret double %.17
}

define i32 @_ZN14example_module7example18new_array_functionB2v3B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo) {
entry:
  %.4 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %try_state = alloca i32, align 4
  store i32 0, i32* %try_state, align 4
  %.41 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, align 8
  %.70 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, align 8
  %.99 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, align 8
  %.128 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %.8 = call i32 @_ZN5numba2np8arrayobj11ol_np_zeros12_3clocals_3e4implB2v4B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, { i8*, i32, i8* }** %excinfo.1, i32 123, i8* null)
  %.9 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.10 = icmp eq i32 %.8, 0
  %.11 = icmp eq i32 %.8, -2
  %.14 = or i1 %.10, %.11
  %.15 = xor i1 %.14, true
  %.16 = icmp sge i32 %.8, 1
  %.17 = select i1 %.16, { i8*, i32, i8* }* %.9, { i8*, i32, i8* }* undef
  %.18 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %.19 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 0
  %.20 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 1
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 2
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 3
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 4
  %.24 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 5
  %.25 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.19, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.20, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.21, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.22, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.23, 4
  %.26 = extractvalue [1 x i32] %.24, 0
  %.27 = insertvalue [1 x i32] undef, i32 %.26, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.27, 5
  %.28 = extractvalue [1 x i32] %.25, 0
  %.29 = insertvalue [1 x i32] undef, i32 %.28, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.29, 6
  br i1 %.15, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store i32 0, i32* %try_state, align 4
  %.33 = load i32, i32* %try_state, align 4
  %.34 = icmp ugt i32 %.33, 0
  %.35 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.17, { i8*, i32, i8* }** %excinfo, align 8
  %.37 = xor i1 %.34, true
  br i1 %.37, label %B0.if.if, label %B0.endif

B0.endif:                                         ; preds = %B0.if, %entry
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, align 8
  %.45 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 5
  %.461 = bitcast [1 x i32]* %.45 to i32*
  %.47 = load i32, i32* %.461, align 4, !range !2
  %.48 = insertvalue [1 x i32] undef, i32 %.47, 0
  %.49 = extractvalue [1 x i32] %.48, 0
  %.50 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 6
  %.51 = load [1 x i32], [1 x i32]* %.50, align 4
  %.52 = extractvalue [1 x i32] %.51, 0
  %.53 = icmp slt i32 0, 0
  %.54 = add i32 0, %.49
  %.55 = select i1 %.53, i32 %.54, i32 0
  %.56 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 5
  %.572 = bitcast [1 x i32]* %.56 to i32*
  %.58 = load i32, i32* %.572, align 4, !range !2
  %.59 = insertvalue [1 x i32] undef, i32 %.58, 0
  %.60 = extractvalue [1 x i32] %.59, 0
  %.61 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 6
  %.62 = load [1 x i32], [1 x i32]* %.61, align 4
  %.63 = extractvalue [1 x i32] %.62, 0
  %.64 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 4
  %.65 = load i32*, i32** %.64, align 8
  %.66 = mul i32 %.55, 1
  %.67 = add i32 0, %.66
  %.68 = getelementptr i32, i32* %.65, i32 %.67
  store i32 1, i32* %.68, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, align 8
  %.74 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 5
  %.753 = bitcast [1 x i32]* %.74 to i32*
  %.76 = load i32, i32* %.753, align 4, !range !2
  %.77 = insertvalue [1 x i32] undef, i32 %.76, 0
  %.78 = extractvalue [1 x i32] %.77, 0
  %.79 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 6
  %.80 = load [1 x i32], [1 x i32]* %.79, align 4
  %.81 = extractvalue [1 x i32] %.80, 0
  %.82 = icmp slt i32 1, 0
  %.83 = add i32 1, %.78
  %.84 = select i1 %.82, i32 %.83, i32 1
  %.85 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 5
  %.864 = bitcast [1 x i32]* %.85 to i32*
  %.87 = load i32, i32* %.864, align 4, !range !2
  %.88 = insertvalue [1 x i32] undef, i32 %.87, 0
  %.89 = extractvalue [1 x i32] %.88, 0
  %.90 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 6
  %.91 = load [1 x i32], [1 x i32]* %.90, align 4
  %.92 = extractvalue [1 x i32] %.91, 0
  %.93 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 4
  %.94 = load i32*, i32** %.93, align 8
  %.95 = mul i32 %.84, 1
  %.96 = add i32 0, %.95
  %.97 = getelementptr i32, i32* %.94, i32 %.96
  store i32 2, i32* %.97, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, align 8
  %.103 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 5
  %.1045 = bitcast [1 x i32]* %.103 to i32*
  %.105 = load i32, i32* %.1045, align 4, !range !2
  %.106 = insertvalue [1 x i32] undef, i32 %.105, 0
  %.107 = extractvalue [1 x i32] %.106, 0
  %.108 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 6
  %.109 = load [1 x i32], [1 x i32]* %.108, align 4
  %.110 = extractvalue [1 x i32] %.109, 0
  %.111 = icmp slt i32 3, 0
  %.112 = add i32 3, %.107
  %.113 = select i1 %.111, i32 %.112, i32 3
  %.114 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 5
  %.1156 = bitcast [1 x i32]* %.114 to i32*
  %.116 = load i32, i32* %.1156, align 4, !range !2
  %.117 = insertvalue [1 x i32] undef, i32 %.116, 0
  %.118 = extractvalue [1 x i32] %.117, 0
  %.119 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 6
  %.120 = load [1 x i32], [1 x i32]* %.119, align 4
  %.121 = extractvalue [1 x i32] %.120, 0
  %.122 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 4
  %.123 = load i32*, i32** %.122, align 8
  %.124 = mul i32 %.113, 1
  %.125 = add i32 0, %.124
  %.126 = getelementptr i32, i32* %.123, i32 %.125
  store i32 3, i32* %.126, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, align 8
  %.132 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 5
  %.1337 = bitcast [1 x i32]* %.132 to i32*
  %.134 = load i32, i32* %.1337, align 4, !range !2
  %.135 = insertvalue [1 x i32] undef, i32 %.134, 0
  %.136 = extractvalue [1 x i32] %.135, 0
  %.137 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 6
  %.138 = load [1 x i32], [1 x i32]* %.137, align 4
  %.139 = extractvalue [1 x i32] %.138, 0
  %.140 = icmp slt i32 4, 0
  %.141 = add i32 4, %.136
  %.142 = select i1 %.140, i32 %.141, i32 4
  %.143 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 5
  %.1448 = bitcast [1 x i32]* %.143 to i32*
  %.145 = load i32, i32* %.1448, align 4, !range !2
  %.146 = insertvalue [1 x i32] undef, i32 %.145, 0
  %.147 = extractvalue [1 x i32] %.146, 0
  %.148 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 6
  %.149 = load [1 x i32], [1 x i32]* %.148, align 4
  %.150 = extractvalue [1 x i32] %.149, 0
  %.151 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 4
  %.152 = load i32*, i32** %.151, align 8
  %.153 = mul i32 %.142, 1
  %.154 = add i32 0, %.153
  %.155 = getelementptr i32, i32* %.152, i32 %.154
  store i32 4, i32* %.155, align 4
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.157 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.158 = extractvalue [1 x i32] %extracted.strides, 0
  call void @NRT_incref(i8* %extracted.meminfo)
  %extracted.meminfo.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.160 = extractvalue [1 x i32] %extracted.shape.1, 0
  %extracted.strides.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.161 = extractvalue [1 x i32] %extracted.strides.1, 0
  %extracted.meminfo.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.163 = extractvalue [1 x i32] %extracted.shape.2, 0
  %.164 = insertvalue [1 x i32] undef, i32 %.163, 0
  %extracted.strides.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.165 = extractvalue [1 x i32] %extracted.strides.2, 0
  %.166 = insertvalue [1 x i32] undef, i32 %.165, 0
  %.167 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %extracted.meminfo.2, 0
  %.168 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.167, i8* %extracted.parent.2, 1
  %.169 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.168, i32 %extracted.nitems.2, 2
  %.170 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.169, i32 %extracted.itemsize.2, 3
  %.171 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.170, i32* %extracted.data.2, 4
  %.172 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.171, [1 x i32] %.164, 5
  %.173 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.172, [1 x i32] %.166, 6
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.173, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  call void @NRT_decref(i8* %extracted.meminfo.1)
  ret i32 0

B0.if.if:                                         ; preds = %B0.if
  ret i32 %.8, !ret_is_raise !1
}

define linkonce_odr i32 @_ZN5numba2np8arrayobj11ol_np_zeros12_3clocals_3e4implB2v4B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i32 %arg.shape, i8* %arg.dtype) {
entry:
  %.16.i = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  %.6 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %try_state = alloca i32, align 4
  store i32 0, i32* %try_state, align 4
  %.46 = alloca i8*, align 8
  store i8* null, i8** %.46, align 8
  %excinfo.2 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.2, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, align 8
  %.10 = call i32 @_ZN5numba2np8arrayobj11ol_np_empty12_3clocals_3e4implB2v5B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, { i8*, i32, i8* }** %excinfo.1, i32 %arg.shape, i8* %arg.dtype)
  %.11 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.12 = icmp eq i32 %.10, 0
  %.13 = icmp eq i32 %.10, -2
  %.16 = or i1 %.12, %.13
  %.17 = xor i1 %.16, true
  %.18 = icmp sge i32 %.10, 1
  %.19 = select i1 %.18, { i8*, i32, i8* }* %.11, { i8*, i32, i8* }* undef
  %.20 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, align 8
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 0
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 1
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 2
  %.24 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 3
  %.25 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 4
  %.26 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 5
  %.27 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.21, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.22, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.23, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.24, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.25, 4
  %.28 = extractvalue [1 x i32] %.26, 0
  %.29 = insertvalue [1 x i32] undef, i32 %.28, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.29, 5
  %.30 = extractvalue [1 x i32] %.27, 0
  %.31 = insertvalue [1 x i32] undef, i32 %.30, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.31, 6
  br i1 %.17, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store i32 0, i32* %try_state, align 4
  %.35 = load i32, i32* %try_state, align 4
  %.36 = icmp ugt i32 %.35, 0
  %.37 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.19, { i8*, i32, i8* }** %excinfo, align 8
  %.39 = xor i1 %.36, true
  br i1 %.39, label %B0.if.if, label %B0.endif

B0.endif:                                         ; preds = %B0.if, %entry
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.43 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.44 = extractvalue [1 x i32] %extracted.strides, 0
  call void @NRT_incref(i8* %extracted.meminfo)
  store i8* null, i8** %.46, align 8
  %extracted.meminfo.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.50 = extractvalue [1 x i32] %extracted.shape.1, 0
  %extracted.strides.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.51 = extractvalue [1 x i32] %extracted.strides.1, 0
  %0 = bitcast { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0)
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i, align 8, !noalias !3
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i, align 8, !noalias !3
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i, align 8, !noalias !3
  %.20.i = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i, i32 0, i32 4
  %.21.i = load i32*, i32** %.20.i, align 8, !noalias !3
  %.22.i = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i, i32 0, i32 3
  %.23.i = load i32, i32* %.22.i, align 4, !noalias !3
  %.24.i = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i, i32 0, i32 2
  %.25.i = load i32, i32* %.24.i, align 4, !noalias !3
  %.26.i = mul i32 %.23.i, %.25.i
  %.27.i = bitcast i32* %.21.i to i8*
  call void @llvm.memset.p0i8.i32(i8* %.27.i, i8 0, i32 %.26.i, i1 false), !noalias !3
  store i8* null, i8** %.46, align 8, !alias.scope !3
  %1 = bitcast { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %1)
  %.53 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.2, align 8
  %.54 = icmp eq i32 0, 0
  %.55 = icmp eq i32 0, -2
  %.58 = or i1 %.54, %.55
  %.59 = xor i1 %.58, true
  %.60 = icmp sge i32 0, 1
  %.61 = select i1 %.60, { i8*, i32, i8* }* %.53, { i8*, i32, i8* }* undef
  %.62 = load i8*, i8** %.46, align 8
  br i1 %.59, label %B0.endif.if, label %B0.endif.endif, !prof !0

B0.if.if:                                         ; preds = %B0.endif.if, %B0.if
  %merge = phi i32 [ %.10, %B0.if ], [ 0, %B0.endif.if ]
  ret i32 %merge, !ret_is_raise !1

B0.endif.if:                                      ; preds = %B0.endif
  %.64 = load i32, i32* %try_state, align 4
  %.65 = icmp ugt i32 %.64, 0
  %.66 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.61, { i8*, i32, i8* }** %excinfo, align 8
  %.68 = xor i1 %.65, true
  br i1 %.68, label %B0.if.if, label %B0.endif.endif

B0.endif.endif:                                   ; preds = %B0.endif.if, %B0.endif
  %extracted.meminfo.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.72 = extractvalue [1 x i32] %extracted.shape.2, 0
  %extracted.strides.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.73 = extractvalue [1 x i32] %extracted.strides.2, 0
  %extracted.meminfo.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.75 = extractvalue [1 x i32] %extracted.shape.3, 0
  %extracted.strides.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.76 = extractvalue [1 x i32] %extracted.strides.3, 0
  call void @NRT_incref(i8* %extracted.meminfo.3)
  %extracted.meminfo.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.78 = extractvalue [1 x i32] %extracted.shape.4, 0
  %extracted.strides.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.79 = extractvalue [1 x i32] %extracted.strides.4, 0
  %extracted.meminfo.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.81 = extractvalue [1 x i32] %extracted.shape.5, 0
  %.82 = insertvalue [1 x i32] undef, i32 %.81, 0
  %extracted.strides.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.83 = extractvalue [1 x i32] %extracted.strides.5, 0
  %.84 = insertvalue [1 x i32] undef, i32 %.83, 0
  %.85 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %extracted.meminfo.5, 0
  %.86 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.85, i8* %extracted.parent.5, 1
  %.87 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.86, i32 %extracted.nitems.5, 2
  %.88 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.87, i32 %extracted.itemsize.5, 3
  %.89 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.88, i32* %extracted.data.5, 4
  %.90 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.89, [1 x i32] %.82, 5
  %.91 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.90, [1 x i32] %.84, 6
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.91, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  call void @NRT_decref(i8* %extracted.meminfo.2)
  call void @NRT_decref(i8* %extracted.meminfo.4)
  ret i32 0
}

; Function Attrs: noinline
define linkonce_odr void @NRT_incref(i8* %.1) #1 {
.3:
  %.4 = icmp eq i8* %.1, null
  br i1 %.4, label %.3.if, label %.3.endif, !prof !0

.3.if:                                            ; preds = %.3
  ret void

.3.endif:                                         ; preds = %.3
  %.7 = bitcast i8* %.1 to i32*
  %.4.i = atomicrmw add i32* %.7, i32 1 monotonic
  %.5.i = add i32 %.4.i, 1
  ret void
}

; Function Attrs: noinline
define linkonce_odr void @NRT_decref(i8* %.1) #1 {
.3:
  %.4 = icmp eq i8* %.1, null
  br i1 %.4, label %.3.if, label %.3.endif, !prof !0

.3.if:                                            ; preds = %.3.endif.if, %.3.endif, %.3
  ret void

.3.endif:                                         ; preds = %.3
  fence release
  %.8 = bitcast i8* %.1 to i32*
  %.4.i = atomicrmw sub i32* %.8, i32 1 monotonic
  %.5.i = sub i32 %.4.i, 1
  %.10 = icmp eq i32 %.5.i, 0
  br i1 %.10, label %.3.endif.if, label %.3.if, !prof !0

.3.endif.if:                                      ; preds = %.3.endif
  fence acquire
  call void @NRT_MemInfo_call_dtor(i8* %.1)
  br label %.3.if
}

declare void @NRT_MemInfo_call_dtor(i8*)

define linkonce_odr i32 @_ZN5numba2np8arrayobj11ol_np_empty12_3clocals_3e4implB2v5B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i32 %arg.shape, i8* %arg.dtype) {
entry:
  %try_state.i.i = alloca i32, align 4
  %.7.i = alloca i8*, align 8
  %excinfo.1.i = alloca { i8*, i32, i8* }*, align 8
  %try_state.i = alloca i32, align 4
  %try_state = alloca i32, align 4
  store i32 0, i32* %try_state, align 4
  %.22 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, align 8
  %.39 = alloca i8*, align 8
  store i8* null, i8** %.39, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %.6 = icmp sgt i32 %arg.shape, 2147483647
  br i1 %.6, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store { i8*, i32, i8* }* @.const.picklebuf.140041118885248, { i8*, i32, i8* }** %excinfo, align 8
  store i32 0, i32* %try_state, align 4
  %.11 = load i32, i32* %try_state, align 4
  %.13 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 1, !ret_is_raise !1

B0.endif:                                         ; preds = %entry
  %.15 = icmp slt i32 %arg.shape, 0
  br i1 %.15, label %B0.endif.if, label %B0.endif.endif, !prof !0

B0.endif.if:                                      ; preds = %B0.endif
  store { i8*, i32, i8* }* @.const.picklebuf.140041119024896, { i8*, i32, i8* }** %excinfo, align 8
  %.18 = load i32, i32* %try_state, align 4
  %.20 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 1, !ret_is_raise !1

B0.endif.endif:                                   ; preds = %B0.endif
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, align 8
  %.25 = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 1, i32 %arg.shape)
  %.26 = extractvalue { i32, i1 } %.25, 0
  %.27 = extractvalue { i32, i1 } %.25, 1
  %.28 = or i1 false, %.27
  %.29 = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 %.26, i32 4)
  %.30 = extractvalue { i32, i1 } %.29, 0
  %.31 = extractvalue { i32, i1 } %.29, 1
  %.32 = or i1 %.28, %.31
  br i1 %.32, label %B0.endif.endif.if, label %B0.endif.endif.endif, !prof !0

B0.endif.endif.if:                                ; preds = %B0.endif.endif
  store { i8*, i32, i8* }* @.const.picklebuf.140041119522880, { i8*, i32, i8* }** %excinfo, align 8
  %.35 = load i32, i32* %try_state, align 4
  %.37 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 1, !ret_is_raise !1

B0.endif.endif.endif:                             ; preds = %B0.endif.endif
  store i8* null, i8** %.39, align 8
  %0 = bitcast i8** %.7.i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0)
  %1 = bitcast { i8*, i32, i8* }** %excinfo.1.i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1)
  %2 = bitcast i32* %try_state.i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2)
  store i8* null, i8** %.7.i, align 8, !noalias !6
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1.i, align 8, !noalias !6
  store i32 0, i32* %try_state.i, align 4, !noalias !6
  store i8* null, i8** %.7.i, align 8, !noalias !6
  %3 = bitcast i32* %try_state.i.i to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3), !noalias !6
  store i32 0, i32* %try_state.i.i, align 4, !noalias !10
  %.7.i.i = call i8* @NRT_MemInfo_alloc_safe_aligned(i32 %.30, i32 32), !noalias !10
  %.8.i.i = icmp eq i8* null, %.7.i.i
  br i1 %.8.i.i, label %B0.if.i.i, label %B0.endif.i.i, !prof !0

B0.if.i.i:                                        ; preds = %B0.endif.endif.endif
  store { i8*, i32, i8* }* @.const.picklebuf.140041117992832, { i8*, i32, i8* }** %excinfo.1.i, align 8, !alias.scope !14, !noalias !15
  store i32 0, i32* %try_state.i.i, align 4, !noalias !10
  %.13.i.i = load i32, i32* %try_state.i.i, align 4, !noalias !10
  %.15.i.i = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1.i, align 8, !alias.scope !14, !noalias !15
  %4 = bitcast i32* %try_state.i.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %4), !noalias !6
  br label %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i

B0.endif.i.i:                                     ; preds = %B0.endif.endif.endif
  store i8* %.7.i.i, i8** %.7.i, align 8, !alias.scope !16, !noalias !17
  %5 = bitcast i32* %try_state.i.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %5), !noalias !6
  br label %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i

_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i: ; preds = %B0.endif.i.i, %B0.if.i.i
  %.111.i = phi i32 [ 1, %B0.if.i.i ], [ 0, %B0.endif.i.i ]
  %.12.i = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1.i, align 8, !noalias !6
  %.13.i = icmp eq i32 %.111.i, 0
  %.18.i = xor i1 %.13.i, true
  %.21.i = load i8*, i8** %.7.i, align 8, !noalias !6
  br i1 %.18.i, label %B0.if.i, label %B0.endif.i, !prof !0

B0.if.i:                                          ; preds = %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i
  store i32 0, i32* %try_state.i, align 4, !noalias !6
  %.25.i = load i32, i32* %try_state.i, align 4, !noalias !6
  %.26.i = icmp ugt i32 %.25.i, 0
  %.27.i = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8, !alias.scope !18, !noalias !19
  store { i8*, i32, i8* }* %.12.i, { i8*, i32, i8* }** %excinfo.1, align 8, !alias.scope !18, !noalias !19
  %.29.i = xor i1 %.26.i, true
  br i1 %.29.i, label %B0.if.if.i, label %B0.endif.i

B0.endif.i:                                       ; preds = %B0.if.i, %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i
  store i8* %.21.i, i8** %.39, align 8, !alias.scope !19, !noalias !18
  %6 = bitcast i8** %.7.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6)
  %7 = bitcast { i8*, i32, i8* }** %excinfo.1.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7)
  %8 = bitcast i32* %try_state.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8)
  br label %_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit

B0.if.if.i:                                       ; preds = %B0.if.i
  %9 = bitcast i8** %.7.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9)
  %10 = bitcast { i8*, i32, i8* }** %excinfo.1.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10)
  %11 = bitcast i32* %try_state.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11)
  br label %_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit

_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit: ; preds = %B0.if.if.i, %B0.endif.i
  %.431 = phi i32 [ 0, %B0.endif.i ], [ %.111.i, %B0.if.if.i ]
  %.44 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.45 = icmp eq i32 %.431, 0
  %.46 = icmp eq i32 %.431, -2
  %.49 = or i1 %.45, %.46
  %.50 = xor i1 %.49, true
  %.51 = icmp sge i32 %.431, 1
  %.52 = select i1 %.51, { i8*, i32, i8* }* %.44, { i8*, i32, i8* }* undef
  %.53 = load i8*, i8** %.39, align 8
  br i1 %.50, label %B0.endif.endif.endif.if, label %B0.endif.endif.endif.endif, !prof !0

B0.endif.endif.endif.if:                          ; preds = %_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit
  %.55 = load i32, i32* %try_state, align 4
  %.56 = icmp ugt i32 %.55, 0
  %.57 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.52, { i8*, i32, i8* }** %excinfo, align 8
  %.59 = xor i1 %.56, true
  br i1 %.59, label %B0.endif.endif.endif.if.if, label %B0.endif.endif.endif.endif

B0.endif.endif.endif.endif:                       ; preds = %B0.endif.endif.endif.if, %_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit
  %.4.i = bitcast i8* %.53 to { i32, i8*, i8*, i8*, i32 }*
  %.5.i = getelementptr { i32, i8*, i8*, i8*, i32 }, { i32, i8*, i8*, i8*, i32 }* %.4.i, i32 0, i32 3
  %.6.i = load i8*, i8** %.5.i, align 8
  %.64 = insertvalue [1 x i32] undef, i32 %arg.shape, 0
  %.65 = insertvalue [1 x i32] undef, i32 4, 0
  %.66 = bitcast i8* %.6.i to i32*
  %.67 = extractvalue [1 x i32] %.64, 0
  %.68 = mul nsw i32 1, %.67
  %.69 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, i32 0, i32 5
  store [1 x i32] %.64, [1 x i32]* %.69, align 4
  %.71 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, i32 0, i32 6
  store [1 x i32] %.65, [1 x i32]* %.71, align 4
  %.73 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, i32 0, i32 4
  store i32* %.66, i32** %.73, align 8
  %.75 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, i32 0, i32 3
  store i32 4, i32* %.75, align 4
  %.772 = bitcast { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22 to i8**
  store i8* %.53, i8** %.772, align 8
  %.79 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, i32 0, i32 1
  store i8* null, i8** %.79, align 8
  %.81 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, i32 0, i32 2
  store i32 %.68, i32* %.81, align 4
  %.83 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.22, align 8
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 5
  %.84 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 6
  %.85 = extractvalue [1 x i32] %extracted.strides, 0
  call void @NRT_incref(i8* %extracted.meminfo)
  %extracted.meminfo.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 0
  %extracted.parent.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 1
  %extracted.nitems.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 2
  %extracted.itemsize.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 3
  %extracted.data.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 4
  %extracted.shape.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 5
  %.87 = extractvalue [1 x i32] %extracted.shape.1, 0
  %extracted.strides.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 6
  %.88 = extractvalue [1 x i32] %extracted.strides.1, 0
  %extracted.meminfo.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 0
  %extracted.parent.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 1
  %extracted.nitems.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 2
  %extracted.itemsize.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 3
  %extracted.data.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 4
  %extracted.shape.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 5
  %.90 = extractvalue [1 x i32] %extracted.shape.2, 0
  %.91 = insertvalue [1 x i32] undef, i32 %.90, 0
  %extracted.strides.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83, 6
  %.92 = extractvalue [1 x i32] %extracted.strides.2, 0
  %.93 = insertvalue [1 x i32] undef, i32 %.92, 0
  %.94 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %extracted.meminfo.2, 0
  %.95 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.94, i8* %extracted.parent.2, 1
  %.96 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.95, i32 %extracted.nitems.2, 2
  %.97 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.96, i32 %extracted.itemsize.2, 3
  %.98 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.97, i32* %extracted.data.2, 4
  %.99 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.98, [1 x i32] %.91, 5
  %.100 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.99, [1 x i32] %.93, 6
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.100, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  call void @NRT_decref(i8* %extracted.meminfo.1)
  ret i32 0

B0.endif.endif.endif.if.if:                       ; preds = %B0.endif.endif.endif.if
  ret i32 %.431, !ret_is_raise !1
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #2

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly, i8, i32, i1 immarg) #3

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #2

; Function Attrs: nounwind readnone speculatable willreturn
declare { i32, i1 } @llvm.smul.with.overflow.i32(i32, i32) #0

declare noalias i8* @NRT_MemInfo_alloc_safe_aligned(i32, i32)

define { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* @example_module.example.new_array_function() {
entry:
  %.2 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.6 = call i32 @_ZN14example_module7example18new_array_functionB2v3B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, { i8*, i32, i8* }** %excinfo) #1
  %.7 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.8 = icmp eq i32 %.6, 0
  %.9 = icmp eq i32 %.6, -2
  %.12 = or i1 %.8, %.9
  %.13 = xor i1 %.12, true
  %.14 = icmp sge i32 %.6, 1
  %.15 = select i1 %.14, { i8*, i32, i8* }* %.7, { i8*, i32, i8* }* undef
  %.16 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  %.17 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 0
  %.18 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 1
  %.19 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 2
  %.20 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 3
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 4
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 5
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.17, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.18, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.19, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.20, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.21, 4
  %.24 = extractvalue [1 x i32] %.22, 0
  %.25 = insertvalue [1 x i32] undef, i32 %.24, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.25, 5
  %.26 = extractvalue [1 x i32] %.23, 0
  %.27 = insertvalue [1 x i32] undef, i32 %.26, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.27, 6
  %.28 = getelementptr { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* null, i32 1
  %.29 = ptrtoint { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.28 to i32
  %.30 = add i32 %.29, 4
  %.31 = call i8* @malloc(i32 %.30)
  %.32 = bitcast i8* %.31 to { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }*
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  ret { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32
}

declare noalias i8* @malloc(i32)

define i32 @_ZN14example_module7example21modify_array_functionB2v9B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i8* %arg.input_array.0, i8* %arg.input_array.1, i32 %arg.input_array.2, i32 %arg.input_array.3, i32* %arg.input_array.4, i32 %arg.input_array.5.0, i32 %arg.input_array.6.0) {
entry:
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %arg.input_array.0, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %arg.input_array.1, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %arg.input_array.2, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %arg.input_array.3, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %arg.input_array.4, 4
  %.11 = insertvalue [1 x i32] undef, i32 %arg.input_array.5.0, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.11, 5
  %.12 = insertvalue [1 x i32] undef, i32 %arg.input_array.6.0, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.12, 6
  %.16 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, align 8
  %.30 = alloca i32, align 4
  store i32 0, i32* %.30, align 4
  %.32 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  %.49 = alloca i32, align 4
  store i32 0, i32* %.49, align 4
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.13 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.14 = extractvalue [1 x i32] %extracted.strides, 0
  call void @NRT_incref(i8* %extracted.meminfo)
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, align 8
  %.20 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, i32 0, i32 5
  %.216 = bitcast [1 x i32]* %.20 to i32*
  %.22 = load i32, i32* %.216, align 4, !range !2
  %.23 = insertvalue [1 x i32] undef, i32 %.22, 0
  %.24 = extractvalue [1 x i32] %.23, 0
  %.25 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, i32 0, i32 6
  %.26 = load [1 x i32], [1 x i32]* %.25, align 4
  %.27 = extractvalue [1 x i32] %.26, 0
  %.28 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, i32 0, i32 4
  %.29 = load i32*, i32** %.28, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  %.36 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, i32 0, i32 5
  %.377 = bitcast [1 x i32]* %.36 to i32*
  %.38 = load i32, i32* %.377, align 4, !range !2
  %.39 = insertvalue [1 x i32] undef, i32 %.38, 0
  %.40 = extractvalue [1 x i32] %.39, 0
  %.41 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, i32 0, i32 6
  %.42 = load [1 x i32], [1 x i32]* %.41, align 4
  %.43 = extractvalue [1 x i32] %.42, 0
  %.44 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, i32 0, i32 4
  %.45 = load i32*, i32** %.44, align 8
  %extracted.meminfo.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.46 = extractvalue [1 x i32] %extracted.shape.1, 0
  %extracted.strides.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.47 = extractvalue [1 x i32] %extracted.strides.1, 0
  call void @NRT_incref(i8* %extracted.meminfo.1)
  store i32 0, i32* %.49, align 4
  %.531 = icmp slt i32 0, %.40
  br i1 %.531, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %.49.promoted = load i32, i32* %.49, align 4
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %lsr.iv = phi i64 [ 0, %for.body.lr.ph ], [ %lsr.iv.next, %for.body ]
  %.593 = phi i32 [ %.49.promoted, %for.body.lr.ph ], [ %spec.select, %for.body ]
  %0 = icmp ugt i32 %.24, 1
  %tmp2 = trunc i64 %lsr.iv to i32
  %spec.select = select i1 %0, i32 %tmp2, i32 %.593
  %.60 = mul i32 %spec.select, 1
  %.61 = add i32 0, %.60
  %.62 = getelementptr i32, i32* %.29, i32 %.61
  %.63 = load i32, i32* %.62, align 4
  %.64 = add i32 %.63, 10
  %scevgep1 = getelementptr i32, i32* %.45, i64 %lsr.iv
  store i32 %.64, i32* %scevgep1, align 4
  %lsr.iv.next = add nuw nsw i64 %lsr.iv, 1
  %tmp3 = trunc i64 %lsr.iv.next to i32
  %.53 = icmp slt i32 %tmp3, %.40
  br i1 %.53, label %for.body, label %for.cond.for.end_crit_edge

for.cond.for.end_crit_edge:                       ; preds = %for.body
  store i32 %spec.select, i32* %.49, align 4
  br label %for.end

for.end:                                          ; preds = %for.cond.for.end_crit_edge, %entry
  %extracted.meminfo.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.71 = extractvalue [1 x i32] %extracted.shape.2, 0
  %extracted.strides.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.72 = extractvalue [1 x i32] %extracted.strides.2, 0
  %extracted.meminfo.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.74 = extractvalue [1 x i32] %extracted.shape.3, 0
  %extracted.strides.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.75 = extractvalue [1 x i32] %extracted.strides.3, 0
  call void @NRT_incref(i8* %extracted.meminfo.3)
  %extracted.meminfo.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.77 = extractvalue [1 x i32] %extracted.shape.4, 0
  %extracted.strides.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.78 = extractvalue [1 x i32] %extracted.strides.4, 0
  %extracted.meminfo.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.80 = extractvalue [1 x i32] %extracted.shape.5, 0
  %.81 = insertvalue [1 x i32] undef, i32 %.80, 0
  %extracted.strides.5 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.82 = extractvalue [1 x i32] %extracted.strides.5, 0
  %.83 = insertvalue [1 x i32] undef, i32 %.82, 0
  %.84 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %extracted.meminfo.5, 0
  %.85 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.84, i8* %extracted.parent.5, 1
  %.86 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.85, i32 %extracted.nitems.5, 2
  %.87 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.86, i32 %extracted.itemsize.5, 3
  %.88 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.87, i32* %extracted.data.5, 4
  %.89 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.88, [1 x i32] %.81, 5
  %.90 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.89, [1 x i32] %.83, 6
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.90, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  call void @NRT_decref(i8* %extracted.meminfo.2)
  call void @NRT_decref(i8* %extracted.meminfo.4)
  ret i32 0
}

define { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* @example_module.example.modify_array_function({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.1) {
entry:
  %.3 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.1, align 8
  %.4 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 5
  %.8 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 6
  %.9 = extractvalue [1 x i32] %extracted.strides, 0
  %.10 = call i32 @_ZN14example_module7example21modify_array_functionB2v9B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, { i8*, i32, i8* }** %excinfo, i8* %extracted.meminfo, i8* %extracted.parent, i32 %extracted.nitems, i32 %extracted.itemsize, i32* %extracted.data, i32 %.8, i32 %.9) #1
  %.11 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.12 = icmp eq i32 %.10, 0
  %.13 = icmp eq i32 %.10, -2
  %.16 = or i1 %.12, %.13
  %.17 = xor i1 %.16, true
  %.18 = icmp sge i32 %.10, 1
  %.19 = select i1 %.18, { i8*, i32, i8* }* %.11, { i8*, i32, i8* }* undef
  %.20 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 0
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 1
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 2
  %.24 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 3
  %.25 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 4
  %.26 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 5
  %.27 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.21, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.22, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.23, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.24, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.25, 4
  %.28 = extractvalue [1 x i32] %.26, 0
  %.29 = insertvalue [1 x i32] undef, i32 %.28, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.29, 5
  %.30 = extractvalue [1 x i32] %.27, 0
  %.31 = insertvalue [1 x i32] undef, i32 %.30, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.31, 6
  %.32 = getelementptr { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* null, i32 1
  %.33 = ptrtoint { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32 to i32
  %.34 = add i32 %.33, 4
  %.35 = call i8* @malloc(i32 %.34)
  %.36 = bitcast i8* %.35 to { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }*
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.36, align 8
  ret { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.36
}

define i32 @_ZN14example_module7example30modify_array_in_place_functionB3v10B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE(i8** noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i8* %arg.input_array.0, i8* %arg.input_array.1, i32 %arg.input_array.2, i32 %arg.input_array.3, i32* %arg.input_array.4, i32 %arg.input_array.5.0, i32 %arg.input_array.6.0) {
entry:
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %arg.input_array.0, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %arg.input_array.1, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %arg.input_array.2, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %arg.input_array.3, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %arg.input_array.4, 4
  %.11 = insertvalue [1 x i32] undef, i32 %arg.input_array.5.0, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.11, 5
  %.12 = insertvalue [1 x i32] undef, i32 %arg.input_array.6.0, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.12, 6
  %.16 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, align 8
  %.30 = alloca i32, align 4
  store i32 0, i32* %.30, align 4
  %.32 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  %.49 = alloca i32, align 4
  store i32 0, i32* %.49, align 4
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.13 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.14 = extractvalue [1 x i32] %extracted.strides, 0
  call void @NRT_incref(i8* %extracted.meminfo)
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, align 8
  %.20 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, i32 0, i32 5
  %.216 = bitcast [1 x i32]* %.20 to i32*
  %.22 = load i32, i32* %.216, align 4, !range !2
  %.23 = insertvalue [1 x i32] undef, i32 %.22, 0
  %.24 = extractvalue [1 x i32] %.23, 0
  %.25 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, i32 0, i32 6
  %.26 = load [1 x i32], [1 x i32]* %.25, align 4
  %.27 = extractvalue [1 x i32] %.26, 0
  %.28 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.16, i32 0, i32 4
  %.29 = load i32*, i32** %.28, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  %.36 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, i32 0, i32 5
  %.377 = bitcast [1 x i32]* %.36 to i32*
  %.38 = load i32, i32* %.377, align 4, !range !2
  %.39 = insertvalue [1 x i32] undef, i32 %.38, 0
  %.40 = extractvalue [1 x i32] %.39, 0
  %.41 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, i32 0, i32 6
  %.42 = load [1 x i32], [1 x i32]* %.41, align 4
  %.43 = extractvalue [1 x i32] %.42, 0
  %.44 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, i32 0, i32 4
  %.45 = load i32*, i32** %.44, align 8
  %extracted.meminfo.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.46 = extractvalue [1 x i32] %extracted.shape.1, 0
  %extracted.strides.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.47 = extractvalue [1 x i32] %extracted.strides.1, 0
  call void @NRT_incref(i8* %extracted.meminfo.1)
  store i32 0, i32* %.49, align 4
  %.531 = icmp slt i32 0, %.40
  br i1 %.531, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %.49.promoted = load i32, i32* %.49, align 4
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %lsr.iv = phi i64 [ 0, %for.body.lr.ph ], [ %lsr.iv.next, %for.body ]
  %.593 = phi i32 [ %.49.promoted, %for.body.lr.ph ], [ %spec.select, %for.body ]
  %0 = icmp ugt i32 %.24, 1
  %tmp2 = trunc i64 %lsr.iv to i32
  %spec.select = select i1 %0, i32 %tmp2, i32 %.593
  %.60 = mul i32 %spec.select, 1
  %.61 = add i32 0, %.60
  %.62 = getelementptr i32, i32* %.29, i32 %.61
  %.63 = load i32, i32* %.62, align 4
  %.64 = mul i32 %.63, 2
  %scevgep1 = getelementptr i32, i32* %.45, i64 %lsr.iv
  store i32 %.64, i32* %scevgep1, align 4
  %lsr.iv.next = add nuw nsw i64 %lsr.iv, 1
  %tmp3 = trunc i64 %lsr.iv.next to i32
  %.53 = icmp slt i32 %tmp3, %.40
  br i1 %.53, label %for.body, label %for.cond.for.end_crit_edge

for.cond.for.end_crit_edge:                       ; preds = %for.body
  store i32 %spec.select, i32* %.49, align 4
  br label %for.end

for.end:                                          ; preds = %for.cond.for.end_crit_edge, %entry
  %extracted.meminfo.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.71 = extractvalue [1 x i32] %extracted.shape.2, 0
  %extracted.strides.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.72 = extractvalue [1 x i32] %extracted.strides.2, 0
  call void @NRT_decref(i8* %extracted.meminfo.2)
  %extracted.meminfo.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.74 = extractvalue [1 x i32] %extracted.shape.3, 0
  %extracted.strides.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.75 = extractvalue [1 x i32] %extracted.strides.3, 0
  call void @NRT_decref(i8* %extracted.meminfo.3)
  store i8* null, i8** %retptr, align 8
  ret i32 0
}

define void @example_module.example.modify_array_in_place_function({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.1) {
entry:
  %.3 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.1, align 8
  %.4 = alloca i8*, align 8
  store i8* null, i8** %.4, align 8
  store i8* null, i8** %.4, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 5
  %.8 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 6
  %.9 = extractvalue [1 x i32] %extracted.strides, 0
  %.10 = call i32 @_ZN14example_module7example30modify_array_in_place_functionB3v10B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE(i8** %.4, { i8*, i32, i8* }** %excinfo, i8* %extracted.meminfo, i8* %extracted.parent, i32 %extracted.nitems, i32 %extracted.itemsize, i32* %extracted.data, i32 %.8, i32 %.9) #1
  %.11 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.12 = icmp eq i32 %.10, 0
  %.13 = icmp eq i32 %.10, -2
  %.16 = or i1 %.12, %.13
  %.17 = xor i1 %.16, true
  %.18 = icmp sge i32 %.10, 1
  %.19 = select i1 %.18, { i8*, i32, i8* }* %.11, { i8*, i32, i8* }* undef
  %.20 = load i8*, i8** %.4, align 8
  ret void
}

define i32 @_ZN14example_module7example29new_and_modify_array_functionB3v11B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo) {
entry:
  %.5 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.5, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %try_state = alloca i32, align 4
  store i32 0, i32* %try_state, align 4
  %.43 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.43, align 8
  %excinfo.2 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.2, align 8
  %.4 = load i8*, i8** @numba.dynamic.globals.7f5ddd208720, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.5, align 8
  %.9 = call i32 @_ZN14example_module7example18new_array_functionB2v3B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.5, { i8*, i32, i8* }** %excinfo.1)
  %.10 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.11 = icmp eq i32 %.9, 0
  %.12 = icmp eq i32 %.9, -2
  %.15 = or i1 %.11, %.12
  %.16 = xor i1 %.15, true
  %.17 = icmp sge i32 %.9, 1
  %.18 = select i1 %.17, { i8*, i32, i8* }* %.10, { i8*, i32, i8* }* undef
  %.19 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.5, align 8
  %.20 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.19, 0
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.19, 1
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.19, 2
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.19, 3
  %.24 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.19, 4
  %.25 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.19, 5
  %.26 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.19, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.20, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.21, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.22, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.23, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.24, 4
  %.27 = extractvalue [1 x i32] %.25, 0
  %.28 = insertvalue [1 x i32] undef, i32 %.27, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.28, 5
  %.29 = extractvalue [1 x i32] %.26, 0
  %.30 = insertvalue [1 x i32] undef, i32 %.29, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.30, 6
  br i1 %.16, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store i32 0, i32* %try_state, align 4
  %.34 = load i32, i32* %try_state, align 4
  %.35 = icmp ugt i32 %.34, 0
  %.36 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.18, { i8*, i32, i8* }** %excinfo, align 8
  %.38 = xor i1 %.35, true
  br i1 %.38, label %B0.if.if, label %B0.endif

B0.endif:                                         ; preds = %B0.if, %entry
  %.42 = load i8*, i8** @numba.dynamic.globals.7f5ddd08f0e0, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.43, align 8
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.47 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.48 = extractvalue [1 x i32] %extracted.strides, 0
  %.49 = call i32 @_ZN14example_module7example21modify_array_functionB2v9B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.43, { i8*, i32, i8* }** %excinfo.2, i8* %extracted.meminfo, i8* %extracted.parent, i32 %extracted.nitems, i32 %extracted.itemsize, i32* %extracted.data, i32 %.47, i32 %.48)
  %.50 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.2, align 8
  %.51 = icmp eq i32 %.49, 0
  %.52 = icmp eq i32 %.49, -2
  %.55 = or i1 %.51, %.52
  %.56 = xor i1 %.55, true
  %.57 = icmp sge i32 %.49, 1
  %.58 = select i1 %.57, { i8*, i32, i8* }* %.50, { i8*, i32, i8* }* undef
  %.59 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.43, align 8
  %.60 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.59, 0
  %.61 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.59, 1
  %.62 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.59, 2
  %.63 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.59, 3
  %.64 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.59, 4
  %.65 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.59, 5
  %.66 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.59, 6
  %inserted.meminfo.1 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.60, 0
  %inserted.parent.1 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo.1, i8* %.61, 1
  %inserted.nitems.1 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent.1, i32 %.62, 2
  %inserted.itemsize.1 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems.1, i32 %.63, 3
  %inserted.data.1 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize.1, i32* %.64, 4
  %.67 = extractvalue [1 x i32] %.65, 0
  %.68 = insertvalue [1 x i32] undef, i32 %.67, 0
  %inserted.shape.1 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data.1, [1 x i32] %.68, 5
  %.69 = extractvalue [1 x i32] %.66, 0
  %.70 = insertvalue [1 x i32] undef, i32 %.69, 0
  %inserted.strides.1 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape.1, [1 x i32] %.70, 6
  br i1 %.56, label %B0.endif.if, label %B0.endif.endif, !prof !0

B0.if.if:                                         ; preds = %B0.endif.if, %B0.if
  %merge = phi i32 [ %.9, %B0.if ], [ %.49, %B0.endif.if ]
  ret i32 %merge, !ret_is_raise !1

B0.endif.if:                                      ; preds = %B0.endif
  %.72 = load i32, i32* %try_state, align 4
  %.73 = icmp ugt i32 %.72, 0
  %.74 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.58, { i8*, i32, i8* }** %excinfo, align 8
  %.76 = xor i1 %.73, true
  br i1 %.76, label %B0.if.if, label %B0.endif.endif

B0.endif.endif:                                   ; preds = %B0.endif.if, %B0.endif
  %extracted.meminfo.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.80 = extractvalue [1 x i32] %extracted.shape.1, 0
  %extracted.strides.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.81 = extractvalue [1 x i32] %extracted.strides.1, 0
  %extracted.meminfo.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 0
  %extracted.parent.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 1
  %extracted.nitems.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 2
  %extracted.itemsize.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 3
  %extracted.data.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 4
  %extracted.shape.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 5
  %.83 = extractvalue [1 x i32] %extracted.shape.2, 0
  %extracted.strides.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 6
  %.84 = extractvalue [1 x i32] %extracted.strides.2, 0
  call void @NRT_incref(i8* %extracted.meminfo.2)
  %extracted.meminfo.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 0
  %extracted.parent.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 1
  %extracted.nitems.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 2
  %extracted.itemsize.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 3
  %extracted.data.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 4
  %extracted.shape.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 5
  %.86 = extractvalue [1 x i32] %extracted.shape.3, 0
  %extracted.strides.3 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 6
  %.87 = extractvalue [1 x i32] %extracted.strides.3, 0
  %extracted.meminfo.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 0
  %extracted.parent.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 1
  %extracted.nitems.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 2
  %extracted.itemsize.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 3
  %extracted.data.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 4
  %extracted.shape.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 5
  %.89 = extractvalue [1 x i32] %extracted.shape.4, 0
  %.90 = insertvalue [1 x i32] undef, i32 %.89, 0
  %extracted.strides.4 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides.1, 6
  %.91 = extractvalue [1 x i32] %extracted.strides.4, 0
  %.92 = insertvalue [1 x i32] undef, i32 %.91, 0
  %.93 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %extracted.meminfo.4, 0
  %.94 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.93, i8* %extracted.parent.4, 1
  %.95 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.94, i32 %extracted.nitems.4, 2
  %.96 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.95, i32 %extracted.itemsize.4, 3
  %.97 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.96, i32* %extracted.data.4, 4
  %.98 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.97, [1 x i32] %.90, 5
  %.99 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.98, [1 x i32] %.92, 6
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.99, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  call void @NRT_decref(i8* %extracted.meminfo.1)
  call void @NRT_decref(i8* %extracted.meminfo.3)
  ret i32 0
}

define { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* @example_module.example.new_and_modify_array_function() {
entry:
  %.2 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.6 = call i32 @_ZN14example_module7example29new_and_modify_array_functionB3v11B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, { i8*, i32, i8* }** %excinfo) #1
  %.7 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.8 = icmp eq i32 %.6, 0
  %.9 = icmp eq i32 %.6, -2
  %.12 = or i1 %.8, %.9
  %.13 = xor i1 %.12, true
  %.14 = icmp sge i32 %.6, 1
  %.15 = select i1 %.14, { i8*, i32, i8* }* %.7, { i8*, i32, i8* }* undef
  %.16 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  %.17 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 0
  %.18 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 1
  %.19 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 2
  %.20 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 3
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 4
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 5
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.17, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.18, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.19, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.20, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.21, 4
  %.24 = extractvalue [1 x i32] %.22, 0
  %.25 = insertvalue [1 x i32] undef, i32 %.24, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.25, 5
  %.26 = extractvalue [1 x i32] %.23, 0
  %.27 = insertvalue [1 x i32] undef, i32 %.26, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.27, 6
  %.28 = getelementptr { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* null, i32 1
  %.29 = ptrtoint { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.28 to i32
  %.30 = add i32 %.29, 4
  %.31 = call i8* @malloc(i32 %.30)
  %.32 = bitcast i8* %.31 to { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }*
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  ret { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32
}

define i32 @_ZN14example_module7example34specially_named_new_array_functionB3v12B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo) {
entry:
  %.4 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %try_state = alloca i32, align 4
  store i32 0, i32* %try_state, align 4
  %.41 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, align 8
  %.70 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, align 8
  %.99 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, align 8
  %.128 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, align 8
  %.157 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %.8 = call i32 @_ZN5numba2np8arrayobj11ol_np_zeros12_3clocals_3e4implB2v4B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, { i8*, i32, i8* }** %excinfo.1, i32 5, i8* null)
  %.9 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.10 = icmp eq i32 %.8, 0
  %.11 = icmp eq i32 %.8, -2
  %.14 = or i1 %.10, %.11
  %.15 = xor i1 %.14, true
  %.16 = icmp sge i32 %.8, 1
  %.17 = select i1 %.16, { i8*, i32, i8* }* %.9, { i8*, i32, i8* }* undef
  %.18 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, align 8
  %.19 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 0
  %.20 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 1
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 2
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 3
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 4
  %.24 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 5
  %.25 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.19, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.20, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.21, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.22, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.23, 4
  %.26 = extractvalue [1 x i32] %.24, 0
  %.27 = insertvalue [1 x i32] undef, i32 %.26, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.27, 5
  %.28 = extractvalue [1 x i32] %.25, 0
  %.29 = insertvalue [1 x i32] undef, i32 %.28, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.29, 6
  br i1 %.15, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store i32 0, i32* %try_state, align 4
  %.33 = load i32, i32* %try_state, align 4
  %.34 = icmp ugt i32 %.33, 0
  %.35 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  store { i8*, i32, i8* }* %.17, { i8*, i32, i8* }** %excinfo, align 8
  %.37 = xor i1 %.34, true
  br i1 %.37, label %B0.if.if, label %B0.endif

B0.endif:                                         ; preds = %B0.if, %entry
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, align 8
  %.45 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 5
  %.461 = bitcast [1 x i32]* %.45 to i32*
  %.47 = load i32, i32* %.461, align 4, !range !2
  %.48 = insertvalue [1 x i32] undef, i32 %.47, 0
  %.49 = extractvalue [1 x i32] %.48, 0
  %.50 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 6
  %.51 = load [1 x i32], [1 x i32]* %.50, align 4
  %.52 = extractvalue [1 x i32] %.51, 0
  %.53 = icmp slt i32 0, 0
  %.54 = add i32 0, %.49
  %.55 = select i1 %.53, i32 %.54, i32 0
  %.56 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 5
  %.572 = bitcast [1 x i32]* %.56 to i32*
  %.58 = load i32, i32* %.572, align 4, !range !2
  %.59 = insertvalue [1 x i32] undef, i32 %.58, 0
  %.60 = extractvalue [1 x i32] %.59, 0
  %.61 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 6
  %.62 = load [1 x i32], [1 x i32]* %.61, align 4
  %.63 = extractvalue [1 x i32] %.62, 0
  %.64 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.41, i32 0, i32 4
  %.65 = load i32*, i32** %.64, align 8
  %.66 = mul i32 %.55, 1
  %.67 = add i32 0, %.66
  %.68 = getelementptr i32, i32* %.65, i32 %.67
  store i32 12345, i32* %.68, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, align 8
  %.74 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 5
  %.753 = bitcast [1 x i32]* %.74 to i32*
  %.76 = load i32, i32* %.753, align 4, !range !2
  %.77 = insertvalue [1 x i32] undef, i32 %.76, 0
  %.78 = extractvalue [1 x i32] %.77, 0
  %.79 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 6
  %.80 = load [1 x i32], [1 x i32]* %.79, align 4
  %.81 = extractvalue [1 x i32] %.80, 0
  %.82 = icmp slt i32 1, 0
  %.83 = add i32 1, %.78
  %.84 = select i1 %.82, i32 %.83, i32 1
  %.85 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 5
  %.864 = bitcast [1 x i32]* %.85 to i32*
  %.87 = load i32, i32* %.864, align 4, !range !2
  %.88 = insertvalue [1 x i32] undef, i32 %.87, 0
  %.89 = extractvalue [1 x i32] %.88, 0
  %.90 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 6
  %.91 = load [1 x i32], [1 x i32]* %.90, align 4
  %.92 = extractvalue [1 x i32] %.91, 0
  %.93 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.70, i32 0, i32 4
  %.94 = load i32*, i32** %.93, align 8
  %.95 = mul i32 %.84, 1
  %.96 = add i32 0, %.95
  %.97 = getelementptr i32, i32* %.94, i32 %.96
  store i32 23451, i32* %.97, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, align 8
  %.103 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 5
  %.1045 = bitcast [1 x i32]* %.103 to i32*
  %.105 = load i32, i32* %.1045, align 4, !range !2
  %.106 = insertvalue [1 x i32] undef, i32 %.105, 0
  %.107 = extractvalue [1 x i32] %.106, 0
  %.108 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 6
  %.109 = load [1 x i32], [1 x i32]* %.108, align 4
  %.110 = extractvalue [1 x i32] %.109, 0
  %.111 = icmp slt i32 2, 0
  %.112 = add i32 2, %.107
  %.113 = select i1 %.111, i32 %.112, i32 2
  %.114 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 5
  %.1156 = bitcast [1 x i32]* %.114 to i32*
  %.116 = load i32, i32* %.1156, align 4, !range !2
  %.117 = insertvalue [1 x i32] undef, i32 %.116, 0
  %.118 = extractvalue [1 x i32] %.117, 0
  %.119 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 6
  %.120 = load [1 x i32], [1 x i32]* %.119, align 4
  %.121 = extractvalue [1 x i32] %.120, 0
  %.122 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.99, i32 0, i32 4
  %.123 = load i32*, i32** %.122, align 8
  %.124 = mul i32 %.113, 1
  %.125 = add i32 0, %.124
  %.126 = getelementptr i32, i32* %.123, i32 %.125
  store i32 34512, i32* %.126, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, align 8
  %.132 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 5
  %.1337 = bitcast [1 x i32]* %.132 to i32*
  %.134 = load i32, i32* %.1337, align 4, !range !2
  %.135 = insertvalue [1 x i32] undef, i32 %.134, 0
  %.136 = extractvalue [1 x i32] %.135, 0
  %.137 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 6
  %.138 = load [1 x i32], [1 x i32]* %.137, align 4
  %.139 = extractvalue [1 x i32] %.138, 0
  %.140 = icmp slt i32 3, 0
  %.141 = add i32 3, %.136
  %.142 = select i1 %.140, i32 %.141, i32 3
  %.143 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 5
  %.1448 = bitcast [1 x i32]* %.143 to i32*
  %.145 = load i32, i32* %.1448, align 4, !range !2
  %.146 = insertvalue [1 x i32] undef, i32 %.145, 0
  %.147 = extractvalue [1 x i32] %.146, 0
  %.148 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 6
  %.149 = load [1 x i32], [1 x i32]* %.148, align 4
  %.150 = extractvalue [1 x i32] %.149, 0
  %.151 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.128, i32 0, i32 4
  %.152 = load i32*, i32** %.151, align 8
  %.153 = mul i32 %.142, 1
  %.154 = add i32 0, %.153
  %.155 = getelementptr i32, i32* %.152, i32 %.154
  store i32 45123, i32* %.155, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, align 8
  %.161 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, i32 0, i32 5
  %.1629 = bitcast [1 x i32]* %.161 to i32*
  %.163 = load i32, i32* %.1629, align 4, !range !2
  %.164 = insertvalue [1 x i32] undef, i32 %.163, 0
  %.165 = extractvalue [1 x i32] %.164, 0
  %.166 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, i32 0, i32 6
  %.167 = load [1 x i32], [1 x i32]* %.166, align 4
  %.168 = extractvalue [1 x i32] %.167, 0
  %.169 = icmp slt i32 4, 0
  %.170 = add i32 4, %.165
  %.171 = select i1 %.169, i32 %.170, i32 4
  %.172 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, i32 0, i32 5
  %.17310 = bitcast [1 x i32]* %.172 to i32*
  %.174 = load i32, i32* %.17310, align 4, !range !2
  %.175 = insertvalue [1 x i32] undef, i32 %.174, 0
  %.176 = extractvalue [1 x i32] %.175, 0
  %.177 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, i32 0, i32 6
  %.178 = load [1 x i32], [1 x i32]* %.177, align 4
  %.179 = extractvalue [1 x i32] %.178, 0
  %.180 = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.157, i32 0, i32 4
  %.181 = load i32*, i32** %.180, align 8
  %.182 = mul i32 %.171, 1
  %.183 = add i32 0, %.182
  %.184 = getelementptr i32, i32* %.181, i32 %.183
  store i32 51234, i32* %.184, align 4
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.186 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.187 = extractvalue [1 x i32] %extracted.strides, 0
  call void @NRT_incref(i8* %extracted.meminfo)
  %extracted.meminfo.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.189 = extractvalue [1 x i32] %extracted.shape.1, 0
  %extracted.strides.1 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.190 = extractvalue [1 x i32] %extracted.strides.1, 0
  %extracted.meminfo.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 0
  %extracted.parent.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 1
  %extracted.nitems.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 2
  %extracted.itemsize.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 3
  %extracted.data.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 4
  %extracted.shape.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5
  %.192 = extractvalue [1 x i32] %extracted.shape.2, 0
  %.193 = insertvalue [1 x i32] undef, i32 %.192, 0
  %extracted.strides.2 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6
  %.194 = extractvalue [1 x i32] %extracted.strides.2, 0
  %.195 = insertvalue [1 x i32] undef, i32 %.194, 0
  %.196 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %extracted.meminfo.2, 0
  %.197 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.196, i8* %extracted.parent.2, 1
  %.198 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.197, i32 %extracted.nitems.2, 2
  %.199 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.198, i32 %extracted.itemsize.2, 3
  %.200 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.199, i32* %extracted.data.2, 4
  %.201 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.200, [1 x i32] %.193, 5
  %.202 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.201, [1 x i32] %.195, 6
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.202, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  call void @NRT_decref(i8* %extracted.meminfo.1)
  ret i32 0

B0.if.if:                                         ; preds = %B0.if
  ret i32 %.8, !ret_is_raise !1
}

define { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* @specially_named_new_array_function() {
entry:
  %.2 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } zeroinitializer, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.6 = call i32 @_ZN14example_module7example34specially_named_new_array_functionB3v12B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, { i8*, i32, i8* }** %excinfo) #1
  %.7 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.8 = icmp eq i32 %.6, 0
  %.9 = icmp eq i32 %.6, -2
  %.12 = or i1 %.8, %.9
  %.13 = xor i1 %.12, true
  %.14 = icmp sge i32 %.6, 1
  %.15 = select i1 %.14, { i8*, i32, i8* }* %.7, { i8*, i32, i8* }* undef
  %.16 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, align 8
  %.17 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 0
  %.18 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 1
  %.19 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 2
  %.20 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 3
  %.21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 4
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 5
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16, 6
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.17, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %.18, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %.19, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %.20, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %.21, 4
  %.24 = extractvalue [1 x i32] %.22, 0
  %.25 = insertvalue [1 x i32] undef, i32 %.24, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.25, 5
  %.26 = extractvalue [1 x i32] %.23, 0
  %.27 = insertvalue [1 x i32] undef, i32 %.26, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.27, 6
  %.28 = getelementptr { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* null, i32 1
  %.29 = ptrtoint { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.28 to i32
  %.30 = add i32 %.29, 4
  %.31 = call i8* @malloc(i32 %.30)
  %.32 = bitcast i8* %.31 to { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }*
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  ret { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32
}

define i32 @_ZN14example_module7example33increment_global_counter_functionB3v13B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE(i8** noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo) {
entry:
  %.4 = load i32, i32* @global_counter, align 4
  %.5 = zext i32 %.4 to i64
  %.6 = sext i32 1 to i64
  %.7 = add nsw i64 %.5, %.6
  %.8 = trunc i64 %.7 to i32
  store i32 %.8, i32* @global_counter, align 4
  store i8* null, i8** %retptr, align 8
  ret i32 0
}

define void @example_module.example.increment_global_counter_function() {
entry:
  %.2 = alloca i8*, align 8
  store i8* null, i8** %.2, align 8
  store i8* null, i8** %.2, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.6 = call i32 @_ZN14example_module7example33increment_global_counter_functionB3v13B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE(i8** %.2, { i8*, i32, i8* }** %excinfo) #1
  %.7 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.8 = icmp eq i32 %.6, 0
  %.9 = icmp eq i32 %.6, -2
  %.12 = or i1 %.8, %.9
  %.13 = xor i1 %.12, true
  %.14 = icmp sge i32 %.6, 1
  %.15 = select i1 %.14, { i8*, i32, i8* }* %.7, { i8*, i32, i8* }* undef
  %.16 = load i8*, i8** %.2, align 8
  ret void
}

define i32 @_ZN14example_module7example18get_global_counterB3v14B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE(i32* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo) {
entry:
  %.4 = load i32, i32* @global_counter, align 4
  store i32 %.4, i32* %retptr, align 4
  ret i32 0
}

define i32 @example_module.example.get_global_counter() {
entry:
  %.2 = alloca i32, align 4
  store i32 0, i32* %.2, align 4
  store i32 0, i32* %.2, align 4
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.6 = call i32 @_ZN14example_module7example18get_global_counterB3v14B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE(i32* %.2, { i8*, i32, i8* }** %excinfo) #1
  %.7 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.8 = icmp eq i32 %.6, 0
  %.9 = icmp eq i32 %.6, -2
  %.12 = or i1 %.8, %.9
  %.13 = xor i1 %.12, true
  %.14 = icmp sge i32 %.6, 1
  %.15 = select i1 %.14, { i8*, i32, i8* }* %.7, { i8*, i32, i8* }* undef
  %.16 = load i32, i32* %.2, align 4
  ret i32 %.16
}

define i32 @_ZN14example_module7example8sum_to_xB3v15B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEj(i32* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i32 %arg.x) {
entry:
  %.5 = zext i32 %arg.x to i64
  %.6 = sext i32 1 to i64
  %.7 = add nsw i64 %.5, %.6
  %.8 = trunc i64 %.7 to i32
  store i32 %.8, i32* %retptr, align 4
  ret i32 0
}

define i32 @example_module.example.sum_to_x(i32 %.1) {
entry:
  %.3 = alloca i32, align 4
  store i32 0, i32* %.3, align 4
  store i32 0, i32* %.3, align 4
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.7 = call i32 @_ZN14example_module7example8sum_to_xB3v15B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEj(i32* %.3, { i8*, i32, i8* }** %excinfo, i32 %.1) #1
  %.8 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.9 = icmp eq i32 %.7, 0
  %.10 = icmp eq i32 %.7, -2
  %.13 = or i1 %.9, %.10
  %.14 = xor i1 %.13, true
  %.15 = icmp sge i32 %.7, 1
  %.16 = select i1 %.15, { i8*, i32, i8* }* %.8, { i8*, i32, i8* }* undef
  %.17 = load i32, i32* %.3, align 4
  ret i32 %.17
}

; Function Attrs: nounwind
declare void @llvm.stackprotector(i8*, i8**) #4

attributes #0 = { nounwind readnone speculatable willreturn }
attributes #1 = { noinline }
attributes #2 = { argmemonly nounwind willreturn }
attributes #3 = { argmemonly nounwind willreturn writeonly }
attributes #4 = { nounwind }

!0 = !{!"branch_weights", i32 1, i32 99}
!1 = !{i1 true}
!2 = !{i32 0, i32 2147483647}
!3 = !{!4}
!4 = distinct !{!4, !5, !"_ZN5numba2np8arrayobj18ol_array_zero_fill12_3clocals_3e4implB2v8B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE: %retptr"}
!5 = distinct !{!5, !"_ZN5numba2np8arrayobj18ol_array_zero_fill12_3clocals_3e4implB2v8B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE"}
!6 = !{!7, !9}
!7 = distinct !{!7, !8, !"_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %retptr"}
!8 = distinct !{!8, !"_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij"}
!9 = distinct !{!9, !8, !"_ZN5numba2np8arrayobj15_call_allocatorB2v6B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %excinfo"}
!10 = !{!11, !13, !7, !9}
!11 = distinct !{!11, !12, !"_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %retptr"}
!12 = distinct !{!12, !"_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij"}
!13 = distinct !{!13, !12, !"_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %excinfo"}
!14 = !{!13}
!15 = !{!11, !7, !9}
!16 = !{!11}
!17 = !{!13, !7, !9}
!18 = !{!9}
!19 = !{!7}
