; ModuleID = 'my_module'
source_filename = "<string>"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.const.picklebuf.139766602895744 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([102 x i8], [102 x i8]* @.const.pickledata.139766602895744, i32 0, i32 0), i32 102, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.139766602895744.sha1, i32 0, i32 0) }
@.const.pickledata.139766602895744 = internal constant [102 x i8] c"\80\04\95[\00\00\00\00\00\00\00\8C\08builtins\94\8C\0CRuntimeError\94\93\94\8C6numba jitted function aborted due to unresolved symbol\94\85\94N\87\94."
@.const.pickledata.139766602895744.sha1 = internal constant [20 x i8] c"\97\BE\DC\DF\EC\8E\80\B7\09>P\CE%\EDV\F7r\0E\0C\9C"
@_ZN08NumbaEnv8__main__21modify_array_functionB2v1B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dE5ArrayIjLi1E1C7mutable7alignedE = common global i8* null
@_ZN08NumbaEnv8__main__18new_array_functionB2v2B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dE = common global i8* null
@_ZN08NumbaEnv8__main__6squareB2v8B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dEd = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj11ol_np_zeros12_3clocals_3e4implB2v3B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29 = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj11ol_np_empty12_3clocals_3e4implB2v4B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29 = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij = common global i8* null
@_ZN08NumbaEnv5numba2np8arrayobj18ol_array_zero_fill12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE = common global i8* null
@.const.picklebuf.139766594134848 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([77 x i8], [77 x i8]* @.const.pickledata.139766594134848, i32 0, i32 0), i32 77, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.139766594134848.sha1, i32 0, i32 0) }
@.const.picklebuf.139766594135616 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([137 x i8], [137 x i8]* @.const.pickledata.139766594135616, i32 0, i32 0), i32 137, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.139766594135616.sha1, i32 0, i32 0) }
@.const.picklebuf.139766593518784 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([86 x i8], [86 x i8]* @.const.pickledata.139766593518784, i32 0, i32 0), i32 86, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.139766593518784.sha1, i32 0, i32 0) }
@.const.pickledata.139766593518784 = internal constant [86 x i8] c"\80\04\95K\00\00\00\00\00\00\00\8C\08builtins\94\8C\0BMemoryError\94\93\94\8C'Allocation failed (probably too large).\94\85\94N\87\94."
@.const.pickledata.139766593518784.sha1 = internal constant [20 x i8] c"\BA(\9D\81\F0\\p \F3G|\15sH\04\DFe\AB\E2\09"
@.const.pickledata.139766594135616 = internal constant [137 x i8] c"\80\04\95~\00\00\00\00\00\00\00\8C\08builtins\94\8C\0AValueError\94\93\94\8C[array is too big; `arr.size * arr.dtype.itemsize` is larger than the maximum possible size.\94\85\94N\87\94."
@.const.pickledata.139766594135616.sha1 = internal constant [20 x i8] c"X\E1N\CC\B5\07\B1\E0 i\81t\02#\E6\85\CB\8C<W"
@.const.pickledata.139766594134848 = internal constant [77 x i8] c"\80\04\95B\00\00\00\00\00\00\00\8C\08builtins\94\8C\0AValueError\94\93\94\8C\1Fnegative dimensions not allowed\94\85\94N\87\94."
@.const.pickledata.139766594134848.sha1 = internal constant [20 x i8] c"3\1B\85c\BD\B9\DA\C8\1B8B\22s\05,Ho\C1pk"
@_ZN08NumbaEnv5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi = common global i8* null
@.const.picklebuf.139766592171328 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([182 x i8], [182 x i8]* @.const.pickledata.139766592171328, i32 0, i32 0), i32 182, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.139766592171328.sha1, i32 0, i32 0) }
@.const.picklebuf.139766593311296 = internal constant { i8*, i32, i8* } { i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.const.pickledata.139766593311296, i32 0, i32 0), i32 69, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.const.pickledata.139766593311296.sha1, i32 0, i32 0) }
@.const.pickledata.139766593311296 = internal constant [69 x i8] c"\80\04\95:\00\00\00\00\00\00\00\8C\08builtins\94\8C\11ZeroDivisionError\94\93\94\8C\10division by zero\94\85\94N\87\94."
@.const.pickledata.139766593311296.sha1 = internal constant [20 x i8] c"\B2\80\08\A0\F8\8B\AD_\F0\F0$>\84\DA\B9\0C\AB\19\B3f"
@.const.pickledata.139766592171328 = internal constant [182 x i8] c"\80\04\95\AB\00\00\00\00\00\00\00\8C\08builtins\94\8C\0DOverflowError\94\93\94)\8C\09int_power\94\8Cw/home/runner/.cache/pypoetry/virtualenvs/numba-wasm-1lEsD5Wz-py3.9/lib/python3.9/site-packages/numba/cpython/numbers.py\94K\DE\87\94\87\94."
@.const.pickledata.139766592171328.sha1 = internal constant [20 x i8] c"Y`\CC\CD\E7\CCljHM\0B\0E\\\DB\04\E7hn+T"

define hidden i32 @nrt_atomic_add(i32* %.1) {
.3:
  %.4 = atomicrmw add i32* %.1, i32 1 monotonic
  %.5 = add i32 %.4, 1
  ret i32 %.5
}

define hidden i32 @nrt_atomic_sub(i32* %.1) {
.3:
  %.4 = atomicrmw sub i32* %.1, i32 1 monotonic
  %.5 = sub i32 %.4, 1
  ret i32 %.5
}

define hidden i32 @nrt_atomic_cas(i32* %.1, i32 %.2, i32 %.3, i32* %.4) {
.6:
  %.7 = cmpxchg i32* %.1, i32 %.2, i32 %.3 monotonic monotonic
  %.8 = extractvalue { i32, i1 } %.7, 0
  %.9 = extractvalue { i32, i1 } %.7, 1
  store i32 %.8, i32* %.4, align 4
  %.11 = zext i1 %.9 to i32
  ret i32 %.11
}

define hidden i8* @NRT_MemInfo_data_fast(i8* %.1) {
.3:
  %.4 = bitcast i8* %.1 to { i32, i8*, i8*, i8*, i32 }*
  %.5 = getelementptr { i32, i8*, i8*, i8*, i32 }, { i32, i8*, i8*, i8*, i32 }* %.4, i32 0, i32 3
  %.6 = load i8*, i8** %.5, align 8
  ret i8* %.6
}

; Function Attrs: noinline
define hidden void @NRT_incref(i8* %.1) #0 {
.3:
  %.4 = icmp eq i8* %.1, null
  br i1 %.4, label %.3.if, label %.3.endif, !prof !0

.3.if:                                            ; preds = %.3
  ret void

.3.endif:                                         ; preds = %.3
  %.7 = bitcast i8* %.1 to i32*
  %.4.i = atomicrmw add i32* %.7, i32 1 monotonic
  %.5.i = add i32 %.4.i, 1
  ret void
}

; Function Attrs: noinline
define hidden void @NRT_decref(i8* %.1) #0 {
.3:
  %.4 = icmp eq i8* %.1, null
  br i1 %.4, label %.3.if, label %.3.endif, !prof !0

.3.if:                                            ; preds = %.3.endif, %.3.endif.if, %.3
  ret void

.3.endif:                                         ; preds = %.3
  fence release
  %.8 = bitcast i8* %.1 to i32*
  %.4.i = atomicrmw sub i32* %.8, i32 1 monotonic
  %.5.i = sub i32 %.4.i, 1
  %.10 = icmp eq i32 %.5.i, 0
  br i1 %.10, label %.3.endif.if, label %.3.if, !prof !0

.3.endif.if:                                      ; preds = %.3.endif
  fence acquire
  call void @NRT_MemInfo_call_dtor(i8* %.1)
  br label %.3.if
}

declare void @NRT_MemInfo_call_dtor(i8*)

define hidden i32 @nrt_unresolved_abort(i8** %.1, { i8*, i32, i8* }** %.2) {
.4:
  store { i8*, i32, i8* }* @.const.picklebuf.139766602895744, { i8*, i32, i8* }** %.2, align 8
  ret i32 1, !ret_is_raise !1
}

define hidden i32 @_ZN8__main__21modify_array_functionB2v1B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dE5ArrayIjLi1E1C7mutable7alignedE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i8* %arg.input_array.0, i8* %arg.input_array.1, i32 %arg.input_array.2, i32 %arg.input_array.3, i32* %arg.input_array.4, i32 %arg.input_array.5.0, i32 %arg.input_array.6.0) {
entry:
  %inserted.meminfo = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %arg.input_array.0, 0
  %inserted.parent = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo, i8* %arg.input_array.1, 1
  %inserted.nitems = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent, i32 %arg.input_array.2, 2
  %inserted.itemsize = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems, i32 %arg.input_array.3, 3
  %inserted.data = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize, i32* %arg.input_array.4, 4
  %.11 = insertvalue [1 x i32] undef, i32 %arg.input_array.5.0, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data, [1 x i32] %.11, 5
  %.12 = insertvalue [1 x i32] undef, i32 %arg.input_array.6.0, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.12, 6
  %inserted.strides.fca.5.0.extract20 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5, 0
  %inserted.strides.fca.6.0.extract21 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6, 0
  %.23 = insertvalue [1 x i32] undef, i32 %inserted.strides.fca.5.0.extract20, 0
  %.26.fca.0.insert = insertvalue [1 x i32] undef, i32 %inserted.strides.fca.6.0.extract21, 0
  call void @NRT_incref(i8* %arg.input_array.0)
  %.531 = icmp slt i32 0, %inserted.strides.fca.5.0.extract20
  br i1 %.531, label %for.body.lr.ph, label %for.end

for.body.lr.ph:                                   ; preds = %entry
  %.55 = icmp ugt i32 %inserted.strides.fca.5.0.extract20, 1
  br label %for.body

for.body:                                         ; preds = %for.body.lr.ph, %for.body
  %loop.index3 = phi i32 [ 0, %for.body.lr.ph ], [ %.69, %for.body ]
  %.49.02 = phi i32 [ 0, %for.body.lr.ph ], [ %spec.select, %for.body ]
  %spec.select = select i1 %.55, i32 %loop.index3, i32 %.49.02
  %.62 = getelementptr i32, i32* %arg.input_array.4, i32 %spec.select
  %.63 = load i32, i32* %.62, align 4
  %.64 = add i32 %.63, 10
  %.67 = getelementptr i32, i32* %arg.input_array.4, i32 %loop.index3
  store i32 %.64, i32* %.67, align 4
  %.69 = add nsw i32 %loop.index3, 1
  %.53 = icmp slt i32 %.69, %inserted.strides.fca.5.0.extract20
  br i1 %.53, label %for.body, label %for.end

for.end:                                          ; preds = %for.body, %entry
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  ret i32 0
}

define { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* @modify_array_function({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.1) {
entry:
  %.3 = load { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.1, align 8
  %.4 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  %.fca.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 0
  store i8* null, i8** %.fca.0.gep, align 8
  %.fca.1.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 1
  store i8* null, i8** %.fca.1.gep, align 8
  %.fca.2.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 2
  store i32 0, i32* %.fca.2.gep, align 8
  %.fca.3.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 3
  store i32 0, i32* %.fca.3.gep, align 4
  %.fca.4.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 4
  store i32* null, i32** %.fca.4.gep, align 8
  %.fca.5.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 5, i32 0
  store i32 0, i32* %.fca.5.0.gep, align 8
  %.fca.6.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 6, i32 0
  store i32 0, i32* %.fca.6.0.gep, align 4
  store i8* null, i8** %.fca.0.gep, align 8
  store i8* null, i8** %.fca.1.gep, align 8
  store i32 0, i32* %.fca.2.gep, align 8
  store i32 0, i32* %.fca.3.gep, align 4
  store i32* null, i32** %.fca.4.gep, align 8
  store i32 0, i32* %.fca.5.0.gep, align 8
  store i32 0, i32* %.fca.6.0.gep, align 4
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %extracted.meminfo = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 0
  %extracted.parent = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 1
  %extracted.nitems = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 2
  %extracted.itemsize = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 3
  %extracted.data = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 4
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 5
  %.8 = extractvalue [1 x i32] %extracted.shape, 0
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.3, 6
  %.9 = extractvalue [1 x i32] %extracted.strides, 0
  %.10 = call i32 @_ZN8__main__21modify_array_functionB2v1B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dE5ArrayIjLi1E1C7mutable7alignedE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, { i8*, i32, i8* }** %excinfo, i8* %extracted.meminfo, i8* %extracted.parent, i32 %extracted.nitems, i32 %extracted.itemsize, i32* %extracted.data, i32 %.8, i32 %.9) #0
  %.11 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.12 = icmp eq i32 %.10, 0
  %.13 = icmp eq i32 %.10, -2
  %.16 = or i1 %.12, %.13
  %.18 = icmp sge i32 %.10, 1
  %.20.fca.0.load = load i8*, i8** %.fca.0.gep, align 8
  %.20.fca.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.20.fca.0.load, 0
  %.20.fca.1.load = load i8*, i8** %.fca.1.gep, align 8
  %.20.fca.1.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.0.insert, i8* %.20.fca.1.load, 1
  %.20.fca.2.load = load i32, i32* %.fca.2.gep, align 8
  %.20.fca.2.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.1.insert, i32 %.20.fca.2.load, 2
  %.20.fca.3.load = load i32, i32* %.fca.3.gep, align 4
  %.20.fca.3.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.2.insert, i32 %.20.fca.3.load, 3
  %.20.fca.4.load = load i32*, i32** %.fca.4.gep, align 8
  %.20.fca.4.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.3.insert, i32* %.20.fca.4.load, 4
  %.20.fca.5.0.load = load i32, i32* %.fca.5.0.gep, align 8
  %.20.fca.5.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.4.insert, i32 %.20.fca.5.0.load, 5, 0
  %.20.fca.6.0.load = load i32, i32* %.fca.6.0.gep, align 4
  %.20.fca.6.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.5.0.insert, i32 %.20.fca.6.0.load, 6, 0
  %.26 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.6.0.insert, 5
  %.27 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.6.0.insert, 6
  %.28 = extractvalue [1 x i32] %.26, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.4.insert, [1 x i32] %.26, 5
  %.30 = extractvalue [1 x i32] %.27, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.27, 6
  %.35 = call i8* @malloc(i32 44)
  %.36 = bitcast i8* %.35 to { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }*
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.36, align 8
  ret { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.36
}

declare noalias i8* @malloc(i32)

define hidden i32 @_ZN8__main__18new_array_functionB2v2B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo) {
entry:
  %.4 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  %.fca.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 0
  store i8* null, i8** %.fca.0.gep, align 8
  %.fca.1.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 1
  store i8* null, i8** %.fca.1.gep, align 8
  %.fca.2.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 2
  store i32 0, i32* %.fca.2.gep, align 8
  %.fca.3.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 3
  store i32 0, i32* %.fca.3.gep, align 4
  %.fca.4.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 4
  store i32* null, i32** %.fca.4.gep, align 8
  %.fca.5.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 5, i32 0
  store i32 0, i32* %.fca.5.0.gep, align 8
  %.fca.6.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, i32 0, i32 6, i32 0
  store i32 0, i32* %.fca.6.0.gep, align 4
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  store i8* null, i8** %.fca.0.gep, align 8
  store i8* null, i8** %.fca.1.gep, align 8
  store i32 0, i32* %.fca.2.gep, align 8
  store i32 0, i32* %.fca.3.gep, align 4
  store i32* null, i32** %.fca.4.gep, align 8
  store i32 0, i32* %.fca.5.0.gep, align 8
  store i32 0, i32* %.fca.6.0.gep, align 4
  %.8 = call i32 @_ZN5numba2np8arrayobj11ol_np_zeros12_3clocals_3e4implB2v3B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.4, { i8*, i32, i8* }** %excinfo.1, i32 123, i8* null)
  %.9 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.10 = icmp eq i32 %.8, 0
  %.11 = icmp eq i32 %.8, -2
  %.14 = or i1 %.10, %.11
  %.15 = xor i1 %.14, true
  %.16 = icmp sge i32 %.8, 1
  %.18.fca.0.load = load i8*, i8** %.fca.0.gep, align 8
  %.18.fca.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.18.fca.0.load, 0
  %.18.fca.1.load = load i8*, i8** %.fca.1.gep, align 8
  %.18.fca.1.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.0.insert, i8* %.18.fca.1.load, 1
  %.18.fca.2.load = load i32, i32* %.fca.2.gep, align 8
  %.18.fca.2.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.1.insert, i32 %.18.fca.2.load, 2
  %.18.fca.3.load = load i32, i32* %.fca.3.gep, align 4
  %.18.fca.3.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.2.insert, i32 %.18.fca.3.load, 3
  %.18.fca.4.load = load i32*, i32** %.fca.4.gep, align 8
  %.18.fca.4.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.3.insert, i32* %.18.fca.4.load, 4
  %.18.fca.5.0.load = load i32, i32* %.fca.5.0.gep, align 8
  %.18.fca.5.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.4.insert, i32 %.18.fca.5.0.load, 5, 0
  %.18.fca.6.0.load = load i32, i32* %.fca.6.0.gep, align 4
  %.18.fca.6.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.5.0.insert, i32 %.18.fca.6.0.load, 6, 0
  %.24 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.6.0.insert, 5
  %.25 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.6.0.insert, 6
  %.26 = extractvalue [1 x i32] %.24, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.18.fca.4.insert, [1 x i32] %.24, 5
  %.28 = extractvalue [1 x i32] %.25, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.25, 6
  br i1 %.15, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store { i8*, i32, i8* }* %.9, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 %.8, !ret_is_raise !1

B0.endif:                                         ; preds = %entry
  %inserted.strides.fca.5.0.extract54 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 5, 0
  %inserted.strides.fca.6.0.extract55 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, 6, 0
  %.48 = insertvalue [1 x i32] undef, i32 %inserted.strides.fca.5.0.extract54, 0
  %.51.fca.0.insert = insertvalue [1 x i32] undef, i32 %inserted.strides.fca.6.0.extract55, 0
  store i32 1, i32* %.18.fca.4.load, align 4
  %.83 = add i32 1, %inserted.strides.fca.5.0.extract54
  %.97 = getelementptr i32, i32* %.18.fca.4.load, i32 1
  store i32 2, i32* %.97, align 4
  %.112 = add i32 3, %inserted.strides.fca.5.0.extract54
  %.126 = getelementptr i32, i32* %.18.fca.4.load, i32 3
  store i32 3, i32* %.126, align 4
  %.141 = add i32 4, %inserted.strides.fca.5.0.extract54
  %.155 = getelementptr i32, i32* %.18.fca.4.load, i32 4
  store i32 4, i32* %.155, align 4
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  ret i32 0
}

define { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* @new_array_function() {
entry:
  %.2 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  %.fca.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, i32 0, i32 0
  store i8* null, i8** %.fca.0.gep, align 8
  %.fca.1.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, i32 0, i32 1
  store i8* null, i8** %.fca.1.gep, align 8
  %.fca.2.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, i32 0, i32 2
  store i32 0, i32* %.fca.2.gep, align 8
  %.fca.3.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, i32 0, i32 3
  store i32 0, i32* %.fca.3.gep, align 4
  %.fca.4.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, i32 0, i32 4
  store i32* null, i32** %.fca.4.gep, align 8
  %.fca.5.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, i32 0, i32 5, i32 0
  store i32 0, i32* %.fca.5.0.gep, align 8
  %.fca.6.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, i32 0, i32 6, i32 0
  store i32 0, i32* %.fca.6.0.gep, align 4
  store i8* null, i8** %.fca.0.gep, align 8
  store i8* null, i8** %.fca.1.gep, align 8
  store i32 0, i32* %.fca.2.gep, align 8
  store i32 0, i32* %.fca.3.gep, align 4
  store i32* null, i32** %.fca.4.gep, align 8
  store i32 0, i32* %.fca.5.0.gep, align 8
  store i32 0, i32* %.fca.6.0.gep, align 4
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.6 = call i32 @_ZN8__main__18new_array_functionB2v2B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dE({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.2, { i8*, i32, i8* }** %excinfo) #0
  %.7 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.8 = icmp eq i32 %.6, 0
  %.9 = icmp eq i32 %.6, -2
  %.12 = or i1 %.8, %.9
  %.14 = icmp sge i32 %.6, 1
  %.16.fca.0.load = load i8*, i8** %.fca.0.gep, align 8
  %.16.fca.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.16.fca.0.load, 0
  %.16.fca.1.load = load i8*, i8** %.fca.1.gep, align 8
  %.16.fca.1.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.0.insert, i8* %.16.fca.1.load, 1
  %.16.fca.2.load = load i32, i32* %.fca.2.gep, align 8
  %.16.fca.2.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.1.insert, i32 %.16.fca.2.load, 2
  %.16.fca.3.load = load i32, i32* %.fca.3.gep, align 4
  %.16.fca.3.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.2.insert, i32 %.16.fca.3.load, 3
  %.16.fca.4.load = load i32*, i32** %.fca.4.gep, align 8
  %.16.fca.4.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.3.insert, i32* %.16.fca.4.load, 4
  %.16.fca.5.0.load = load i32, i32* %.fca.5.0.gep, align 8
  %.16.fca.5.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.4.insert, i32 %.16.fca.5.0.load, 5, 0
  %.16.fca.6.0.load = load i32, i32* %.fca.6.0.gep, align 4
  %.16.fca.6.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.5.0.insert, i32 %.16.fca.6.0.load, 6, 0
  %.22 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.6.0.insert, 5
  %.23 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.6.0.insert, 6
  %.24 = extractvalue [1 x i32] %.22, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.16.fca.4.insert, [1 x i32] %.22, 5
  %.26 = extractvalue [1 x i32] %.23, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.23, 6
  %.31 = call i8* @malloc(i32 44)
  %.32 = bitcast i8* %.31 to { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }*
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32, align 8
  ret { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.32
}

define hidden i32 @_ZN8__main__6squareB2v8B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dEd(double* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, double %arg.input_value) {
entry:
  %.5 = alloca double, align 8
  store double 0.000000e+00, double* %.5, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  store double 0.000000e+00, double* %.5, align 8
  br label %B138.i

B138.i:                                           ; preds = %entry, %B138.i
  %exp.4.04.i = phi i64 [ %.138.i, %B138.i ], [ 2, %entry ]
  %a.1.2.03.i = phi double [ %.143.i, %B138.i ], [ %arg.input_value, %entry ]
  %r.2.02.i = phi double [ %spec.select.i, %B138.i ], [ 1.000000e+00, %entry ]
  %.120.i = and i64 %exp.4.04.i, 1
  %.121.i = icmp ne i64 %.120.i, 0
  %.125.i = fmul double %r.2.02.i, %a.1.2.03.i
  %spec.select.i = select i1 %.121.i, double %.125.i, double %r.2.02.i
  %.138.i = ashr i64 %exp.4.04.i, 1
  %.143.i = fmul double %a.1.2.03.i, %a.1.2.03.i
  %.112.i = icmp ne i64 %.138.i, 0
  br i1 %.112.i, label %B138.i, label %_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi.exit

_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi.exit: ; preds = %B138.i
  %spec.select.i.lcssa = phi double [ %spec.select.i, %B138.i ]
  store double %spec.select.i.lcssa, double* %.5, align 8, !alias.scope !2, !noalias !5
  %.10 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.11 = icmp eq i32 0, 0
  %.12 = icmp eq i32 0, -2
  %.15 = or i1 %.11, %.12
  %.16 = xor i1 %.15, true
  %.17 = icmp sge i32 0, 1
  %.19 = load double, double* %.5, align 8
  br i1 %.16, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi.exit
  store { i8*, i32, i8* }* %.10, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 0, !ret_is_raise !1

B0.endif:                                         ; preds = %_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi.exit
  store double %.19, double* %retptr, align 8
  ret i32 0
}

define double @square(double %.1) {
entry:
  %.3 = alloca double, align 8
  store double 0.000000e+00, double* %.3, align 8
  %excinfo = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo, align 8
  %.7 = call i32 @_ZN8__main__6squareB2v8B42c8tJTC_2fWQESiLSjagd7GiBiYRFEJmKUJAA_3d_3dEd(double* %.3, { i8*, i32, i8* }** %excinfo, double %.1) #0
  %.8 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo, align 8
  %.9 = icmp eq i32 %.7, 0
  %.10 = icmp eq i32 %.7, -2
  %.13 = or i1 %.9, %.10
  %.15 = icmp sge i32 %.7, 1
  %.17 = load double, double* %.3, align 8
  ret double %.17
}

define linkonce_odr hidden i32 @_ZN5numba2np8arrayobj11ol_np_zeros12_3clocals_3e4implB2v3B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i32 %arg.shape, i8* %arg.dtype) {
entry:
  %.6 = alloca { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, align 8
  %.fca.0.gep1 = bitcast { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6 to i8**
  store i8* null, i8** %.fca.0.gep1, align 8
  %.fca.1.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, i32 0, i32 1
  store i8* null, i8** %.fca.1.gep, align 8
  %.fca.2.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, i32 0, i32 2
  store i32 0, i32* %.fca.2.gep, align 8
  %.fca.3.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, i32 0, i32 3
  store i32 0, i32* %.fca.3.gep, align 4
  %.fca.4.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, i32 0, i32 4
  store i32* null, i32** %.fca.4.gep, align 8
  %.fca.5.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, i32 0, i32 5, i32 0
  store i32 0, i32* %.fca.5.0.gep, align 8
  %.fca.6.0.gep = getelementptr inbounds { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, i32 0, i32 6, i32 0
  store i32 0, i32* %.fca.6.0.gep, align 4
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %.46 = alloca i8*, align 8
  store i8* null, i8** %.46, align 8
  %excinfo.2 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.2, align 8
  store i8* null, i8** %.fca.0.gep1, align 8
  store i8* null, i8** %.fca.1.gep, align 8
  store i32 0, i32* %.fca.2.gep, align 8
  store i32 0, i32* %.fca.3.gep, align 4
  store i32* null, i32** %.fca.4.gep, align 8
  store i32 0, i32* %.fca.5.0.gep, align 8
  store i32 0, i32* %.fca.6.0.gep, align 4
  %.10 = call i32 @_ZN5numba2np8arrayobj11ol_np_empty12_3clocals_3e4implB2v4B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %.6, { i8*, i32, i8* }** %excinfo.1, i32 %arg.shape, i8* %arg.dtype)
  %.11 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.12 = icmp eq i32 %.10, 0
  %.13 = icmp eq i32 %.10, -2
  %.16 = or i1 %.12, %.13
  %.17 = xor i1 %.16, true
  %.20.fca.0.load = load i8*, i8** %.fca.0.gep1, align 8
  %.20.fca.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.20.fca.0.load, 0
  %.20.fca.1.load = load i8*, i8** %.fca.1.gep, align 8
  %.20.fca.1.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.0.insert, i8* %.20.fca.1.load, 1
  %.20.fca.2.load = load i32, i32* %.fca.2.gep, align 8
  %.20.fca.2.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.1.insert, i32 %.20.fca.2.load, 2
  %.20.fca.3.load = load i32, i32* %.fca.3.gep, align 4
  %.20.fca.3.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.2.insert, i32 %.20.fca.3.load, 3
  %.20.fca.4.load = load i32*, i32** %.fca.4.gep, align 8
  %.20.fca.4.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.3.insert, i32* %.20.fca.4.load, 4
  %.20.fca.5.0.load = load i32, i32* %.fca.5.0.gep, align 8
  %.20.fca.5.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.4.insert, i32 %.20.fca.5.0.load, 5, 0
  %.20.fca.6.0.load = load i32, i32* %.fca.6.0.gep, align 4
  %.20.fca.6.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.5.0.insert, i32 %.20.fca.6.0.load, 6, 0
  %.26 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.6.0.insert, 5
  %.27 = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.6.0.insert, 6
  %.28 = extractvalue [1 x i32] %.26, 0
  %inserted.shape = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.20.fca.4.insert, [1 x i32] %.26, 5
  %.30 = extractvalue [1 x i32] %.27, 0
  %inserted.strides = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape, [1 x i32] %.27, 6
  br i1 %.17, label %B0.if, label %B0.endif, !prof !0

B0.if:                                            ; preds = %entry
  store { i8*, i32, i8* }* %.11, { i8*, i32, i8* }** %excinfo, align 8
  br label %B0.if.if

B0.endif:                                         ; preds = %entry
  call void @NRT_incref(i8* %.20.fca.0.load)
  store i8* null, i8** %.46, align 8
  %inserted.meminfo.i = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.20.fca.0.load, 0
  %inserted.parent.i = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.meminfo.i, i8* %.20.fca.1.load, 1
  %inserted.nitems.i = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.parent.i, i32 %.20.fca.2.load, 2
  %inserted.itemsize.i = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.nitems.i, i32 %.20.fca.3.load, 3
  %inserted.data.i = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.itemsize.i, i32* %.20.fca.4.load, 4
  %inserted.shape.i = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.data.i, [1 x i32] %.26, 5
  %inserted.strides.i = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.shape.i, [1 x i32] %.27, 6
  %.26.i = mul i32 %.20.fca.3.load, %.20.fca.2.load
  %.27.i = bitcast i32* %.20.fca.4.load to i8*
  call void @llvm.memset.p0i8.i32(i8* %.27.i, i8 0, i32 %.26.i, i1 false), !noalias !7
  store i8* null, i8** %.46, align 8, !alias.scope !7
  %.53 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.2, align 8
  %.54 = icmp eq i32 0, 0
  %.55 = icmp eq i32 0, -2
  %.58 = or i1 %.54, %.55
  %.59 = xor i1 %.58, true
  br i1 %.59, label %B0.endif.if, label %B0.endif.endif, !prof !0

B0.if.if:                                         ; preds = %B0.endif.if, %B0.if
  %merge = phi i32 [ %.10, %B0.if ], [ 0, %B0.endif.if ]
  ret i32 %merge, !ret_is_raise !1

B0.endif.if:                                      ; preds = %B0.endif
  store { i8*, i32, i8* }* %.53, { i8*, i32, i8* }** %excinfo, align 8
  br label %B0.if.if

B0.endif.endif:                                   ; preds = %B0.endif
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %inserted.strides, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  call void @NRT_decref(i8* %.20.fca.0.load)
  ret i32 0
}

define linkonce_odr hidden i32 @_ZN5numba2np8arrayobj11ol_np_empty12_3clocals_3e4implB2v4B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEi17class_28uint32_29({ i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* noalias nocapture %retptr, { i8*, i32, i8* }** noalias nocapture %excinfo, i32 %arg.shape, i8* %arg.dtype) {
entry:
  %.7.i = alloca i8*, align 8
  %excinfo.1.i = alloca { i8*, i32, i8* }*, align 8
  %.39 = alloca i8*, align 8
  store i8* null, i8** %.39, align 8
  %excinfo.1 = alloca { i8*, i32, i8* }*, align 8
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1, align 8
  %.15 = icmp slt i32 %arg.shape, 0
  br i1 %.15, label %B0.endif.if, label %B0.endif.endif, !prof !0

B0.endif.if:                                      ; preds = %entry
  store { i8*, i32, i8* }* @.const.picklebuf.139766594134848, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 1, !ret_is_raise !1

B0.endif.endif:                                   ; preds = %entry
  %.25 = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 1, i32 %arg.shape)
  %.26 = extractvalue { i32, i1 } %.25, 0
  %.27 = extractvalue { i32, i1 } %.25, 1
  %.29 = call { i32, i1 } @llvm.smul.with.overflow.i32(i32 %.26, i32 4)
  %.30 = extractvalue { i32, i1 } %.29, 0
  %.31 = extractvalue { i32, i1 } %.29, 1
  %.32 = or i1 %.27, %.31
  br i1 %.32, label %B0.endif.endif.if, label %B0.endif.endif.endif, !prof !0

B0.endif.endif.if:                                ; preds = %B0.endif.endif
  store { i8*, i32, i8* }* @.const.picklebuf.139766594135616, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 1, !ret_is_raise !1

B0.endif.endif.endif:                             ; preds = %B0.endif.endif
  store i8* null, i8** %.39, align 8
  %0 = bitcast i8** %.7.i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0)
  %1 = bitcast { i8*, i32, i8* }** %excinfo.1.i to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1)
  store i8* null, i8** %.7.i, align 8, !noalias !10
  store { i8*, i32, i8* }* null, { i8*, i32, i8* }** %excinfo.1.i, align 8, !noalias !10
  store i8* null, i8** %.7.i, align 8, !noalias !10
  %.7.i.i = call i8* @NRT_MemInfo_alloc_safe_aligned(i32 %.30, i32 32), !noalias !14
  %.8.i.i = icmp eq i8* null, %.7.i.i
  br i1 %.8.i.i, label %B0.if.i.i, label %B0.endif.i.i, !prof !0

B0.if.i.i:                                        ; preds = %B0.endif.endif.endif
  store { i8*, i32, i8* }* @.const.picklebuf.139766593518784, { i8*, i32, i8* }** %excinfo.1.i, align 8, !alias.scope !18, !noalias !19
  br label %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i

B0.endif.i.i:                                     ; preds = %B0.endif.endif.endif
  store i8* %.7.i.i, i8** %.7.i, align 8, !alias.scope !20, !noalias !21
  br label %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i

_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i: ; preds = %B0.endif.i.i, %B0.if.i.i
  %.111.i = phi i32 [ 1, %B0.if.i.i ], [ 0, %B0.endif.i.i ]
  %.12.i = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1.i, align 8, !noalias !10
  %.13.i = icmp eq i32 %.111.i, 0
  %.18.i = xor i1 %.13.i, true
  %.21.i = load i8*, i8** %.7.i, align 8, !noalias !10
  br i1 %.18.i, label %B0.if.i, label %B0.endif.i, !prof !0

B0.if.i:                                          ; preds = %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i
  store { i8*, i32, i8* }* %.12.i, { i8*, i32, i8* }** %excinfo.1, align 8, !alias.scope !22, !noalias !23
  %2 = bitcast i8** %.7.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2)
  %3 = bitcast { i8*, i32, i8* }** %excinfo.1.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3)
  br label %_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit

B0.endif.i:                                       ; preds = %_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit.i
  store i8* %.21.i, i8** %.39, align 8, !alias.scope !23, !noalias !22
  %4 = bitcast i8** %.7.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4)
  %5 = bitcast { i8*, i32, i8* }** %excinfo.1.i to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5)
  br label %_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit

_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit: ; preds = %B0.endif.i, %B0.if.i
  %.431 = phi i32 [ %.111.i, %B0.if.i ], [ 0, %B0.endif.i ]
  %.44 = load { i8*, i32, i8* }*, { i8*, i32, i8* }** %excinfo.1, align 8
  %.45 = icmp eq i32 %.431, 0
  %.46 = icmp eq i32 %.431, -2
  %.49 = or i1 %.45, %.46
  %.50 = xor i1 %.49, true
  %.53 = load i8*, i8** %.39, align 8
  br i1 %.50, label %B0.endif.endif.endif.if, label %B0.endif.endif.endif.endif, !prof !0

B0.endif.endif.endif.if:                          ; preds = %_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit
  store { i8*, i32, i8* }* %.44, { i8*, i32, i8* }** %excinfo, align 8
  ret i32 %.431, !ret_is_raise !1

B0.endif.endif.endif.endif:                       ; preds = %_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij.exit
  %.4.i = bitcast i8* %.53 to { i32, i8*, i8*, i8*, i32 }*
  %.5.i = getelementptr { i32, i8*, i8*, i8*, i32 }, { i32, i8*, i8*, i8*, i32 }* %.4.i, i32 0, i32 3
  %.6.i = load i8*, i8** %.5.i, align 8
  %.64 = insertvalue [1 x i32] undef, i32 %arg.shape, 0
  %.66 = bitcast i8* %.6.i to i32*
  %.83.fca.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } undef, i8* %.53, 0
  %.83.fca.1.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.0.insert, i8* null, 1
  %.83.fca.2.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.1.insert, i32 %arg.shape, 2
  %.83.fca.3.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.2.insert, i32 4, 3
  %.83.fca.4.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.3.insert, i32* %.66, 4
  %.83.fca.5.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.4.insert, i32 %arg.shape, 5, 0
  %.83.fca.6.0.insert = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.5.0.insert, i32 4, 6, 0
  %extracted.shape = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.6.0.insert, 5
  %extracted.strides = extractvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.6.0.insert, 6
  %.90 = extractvalue [1 x i32] %extracted.shape, 0
  %.92 = extractvalue [1 x i32] %extracted.strides, 0
  %.99 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.83.fca.4.insert, [1 x i32] %extracted.shape, 5
  %.100 = insertvalue { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.99, [1 x i32] %extracted.strides, 6
  store { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] } %.100, { i8*, i8*, i32, i32, i32*, [1 x i32], [1 x i32] }* %retptr, align 8
  ret i32 0
}

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p0i8.i32(i8* nocapture writeonly, i8, i32, i1 immarg) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare { i32, i1 } @llvm.smul.with.overflow.i32(i32, i32) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #3

declare noalias i8* @NRT_MemInfo_alloc_safe_aligned(i32, i32)

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #3

; Function Attrs: nounwind readnone speculatable willreturn
declare double @llvm.pow.f64(double, double) #2

attributes #0 = { noinline }
attributes #1 = { argmemonly nounwind willreturn writeonly }
attributes #2 = { nounwind readnone speculatable willreturn }
attributes #3 = { argmemonly nounwind willreturn }

!0 = !{!"branch_weights", i32 1, i32 99}
!1 = !{i1 true}
!2 = !{!3}
!3 = distinct !{!3, !4, !"_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi: %retptr"}
!4 = distinct !{!4, !"_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi"}
!5 = !{!6}
!6 = distinct !{!6, !4, !"_ZN5numba7cpython7numbers14int_power_impl12_3clocals_3e9int_powerB2v9B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEdi: %excinfo"}
!7 = !{!8}
!8 = distinct !{!8, !9, !"_ZN5numba2np8arrayobj18ol_array_zero_fill12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE: %retptr"}
!9 = distinct !{!9, !"_ZN5numba2np8arrayobj18ol_array_zero_fill12_3clocals_3e4implB2v7B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dE5ArrayIjLi1E1C7mutable7alignedE"}
!10 = !{!11, !13}
!11 = distinct !{!11, !12, !"_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %retptr"}
!12 = distinct !{!12, !"_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij"}
!13 = distinct !{!13, !12, !"_ZN5numba2np8arrayobj15_call_allocatorB2v5B44c8tJTC_2fWQA9wW1DkAz0Pj1skAdT4gkkUlYBZmgA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %excinfo"}
!14 = !{!15, !17, !11, !13}
!15 = distinct !{!15, !16, !"_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %retptr"}
!16 = distinct !{!16, !"_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij"}
!17 = distinct !{!17, !16, !"_ZN5numba2np8arrayobj18_ol_array_allocate12_3clocals_3e4implB2v6B42c8tJTIcFHzwl2ILiXkcBV0KBSmNGHkyiCKJEEwA_3dEN29typeref_5b_3cclass_20_27numba4core5types8npytypes14Array_27_3e_5dEij: %excinfo"}
!18 = !{!17}
!19 = !{!15, !11, !13}
!20 = !{!15}
!21 = !{!17, !11, !13}
!22 = !{!13}
!23 = !{!11}
